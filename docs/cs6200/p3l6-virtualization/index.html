<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          Eric&#39;s CS Notes
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.css">
    
    <!-- katex css -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.css" integrity="sha384-Juol1FqnotbkyZUT5Z7gUPjQ9gzlwCENvUZTpQBAPxtusdwFLRy382PSDx5UUJ4/" crossorigin="anonymous">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 6.3.0"></head>


<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>ERIC&#39;S CS NOTES</span>
  </a>
</div>

    <div class="book-menu">
  <!--
## Introduction to Probability

* [Unit 1: Probability models and axioms](/introduction-to-probability/unit-1/index.html)
* [Unit 2: Conditioning and independence](/introduction-to-probability/unit-2/index.html)
* [Unit 3: Counting](/introduction-to-probability/unit-3/index.html)
* [Unit 4: Discrete random variables](/introduction-to-probability/unit-4/index.html)
* [Unit 5: Continuous random variables](/introduction-to-probability/unit-5/index.html)
* [Unit 6: Further topics on random variables](/introduction-to-probability/unit-6/index.html)
* [Unit 7: Bayesian inference](/introduction-to-probability/unit-7/index.html)
* [Unit 8: Limit theorems and classical statistics](/introduction-to-probability/unit-8/index.html)
* [Unit 9: Bernoulli and Poisson processes](/introduction-to-probability/unit-9/index.html)
* [Unit 10: Markov chains](/introduction-to-probability/unit-10/index.html)
-->
<!--
## Multivariable Calculus

* [Unit 1: Thinking about multivariable functions](/multivariable-calculus/unit-1/index.html)
* [Unit 2: Derivatives of multivariable functions](/multivariable-calculus/unit-2/index.html)

* [Unit 3: Applications of multivariable derivatives](/multivariable-calculus/unit-3/index.html)
* [Unit 4: Integrating multivariable functions](/multivariable-calculus/unit-4/index.html)
* [Unit 5: Green's, Stokes', and the divergence theorems](/multivariable-calculus/unit-5/index.html)
-->
<h2 id="CS6210-Advanced-Operating-Systems">CS6210: Advanced Operating Systems</h2>
<ul>
<li><a href="/cs6210/lesson-02/index.html">Lesson 02: OS Structure</a></li>
<li><a href="/cs6210/lesson-03/index.html">Lesson 3: Virtualization</a></li>
<li><a href="/cs6210/lesson-04a/index.html">Lesson 4: Parallel Systems - Part 1</a></li>
<li><a href="/cs6210/lesson-04b/index.html">Lesson 4: Parallel Systems - Part 2</a></li>
<li><a href="/cs6210/lesson-05/index.html">Lesson 5: Distributed Systems</a></li>
<li><a href="/cs6210/lesson-06/index.html">Lesson 6: Distributed Objects and Middleware</a></li>
<li><a href="/cs6210/lesson-07a/index.html">Lesson 7: Distributed Subsystems - GMS</a></li>
<li><a href="/cs6210/lesson-07b/index.html">Lesson 7: Distributed Subsystems - DSM</a></li>
<li><a href="/cs6210/lesson-07c/index.html">Lesson 7: Distributed Subsystems - DFS</a></li>
<li><a href="/cs6210/lesson-09/index.html">Lesson 9: Internet Computing</a></li>
</ul>
<!--
* [Lesson 10: RT and Multimedia](/cs6210/lesson-10/index.html)
* [Lesson 8: Failures and Recovery](/cs6210/lesson-08/index.html)
* [Lesson 11: Security](/cs6210/lesson-11/index.html)
-->
<h2 id="CS6250-Computer-Networks">CS6250 Computer Networks</h2>
<ul>
<li><a href="/cs6250/week-1-internet-architecture/index.html">Week 1 - Internet Architecture</a></li>
<li><a href="/cs6250/week-2-transport-and-application-layers/index.html">Week 2 - Transport and Application Layers</a></li>
<li><a href="/cs6250/week-3-intradomain-routing/index.html">Week 3 - Intradomain Routing</a></li>
<li><a href="/cs6250/week-4-as-relationships-and-interdomain-routing/index.html">Week 4 - AS Relationships and Interdomain Routing</a></li>
<li><a href="/cs6250/week-5-router-design-and-algorithems-part-1/index.html">Week 5 - Router Design and Algorithms (Part 1)</a></li>
<li><a href="/cs6250/week-6-router-design-and-algorithems-part-2/index.html">Week 6 - Router Design and Algorithms (Part 2)</a></li>
<li><a href="/cs6250/week-7-software-defined-networking-part-1/index.html">Week 7 - Software Defined Networking (Part 1)</a></li>
<li><a href="/cs6250/week-8-software-defined-networking-part-2/index.html">Week 8 - Software Defined Networking (Part 2)</a></li>
<li><a href="/cs6250/week-9-internet-security/index.html">Week 9 - Internet Security</a></li>
<li><a href="/cs6250/week-10-internet-surveillance-and-censorship/index.html">Week 10 - Internet Surveillance and Censorship</a></li>
<li><a href="/cs6250/week-11-applications-video/index.html">Week 11 - Applications Videos</a></li>
<li><a href="/cs6250/week-12-applications-cdns-and-overlay-networks/index.html">Week 12 - Applications CDNs and Overlay Networks</a></li>
</ul>
<h2 id="CS6200-Graduate-Introduction-to-Operating-Systems">CS6200 Graduate Introduction to Operating Systems</h2>
<ul>
<li><a href="/cs6200/p1-preparation/index.html">P0 - Preparation</a></li>
<li><a href="/cs6200/p1l2-introduction/index.html">P1L2 - Introduction</a></li>
<li><a href="/cs6200/p2l1-processes-and-process-management/index.html">P2L1 - Processes and Process Management</a></li>
<li><a href="/cs6200/p2l2-threads-and-concurrency/index.html">P2L2 - Threads and Concurrency</a></li>
<li><a href="/cs6200/p2l3-pthread/index.html">P2L3 - PThread</a></li>
<li><a href="/cs6200/p2l4-thread-design-consideration/index.html">P2L4 - Thread Design Considerations</a></li>
<li><a href="/cs6200/p2l5-thread-performance-consideration/index.html">P2L5 - Thread Performance Considerations</a></li>
<li><a href="/cs6200/p3l1-scheduling/index.html">P3L1 - Scheduling</a></li>
<li><a href="/cs6200/p3l2-memory-management/index.html">P3L2 - Memory Management</a></li>
<li><a href="/cs6200/p3l3-inter-process-communication/index.html">P3L3 - Inter-Process Communication</a></li>
<li><a href="/cs6200/p3l4-synchronization-constructs/index.html">P3L4 - Synchronization Constructs</a></li>
<li><a href="/cs6200/p3l5-io-management/index.html">P3L5 - I/O Management</a></li>
<li><a href="/cs6200/p3l6-virtualization/index.html">P3L6 - Virtualization</a></li>
</ul>
<!--
* [P4L1 - Remote Procedure Calls](/cs6200/p4l1-remote-procedure-calls/index.html) 
* [P4L2 - Distributed File Systems](/cs6200/p4l2-distributed-file-systems/index.html) 
* [P4L3 - Distributed Shared Memory](/cs6200/p4l3-distributed-shared-memory/index.html) 
* [P4L4 - Datacenter Technologies](/cs6200/p4l4-datacenter-technologies/index.html) 
-->
<h2 id="Algorithms-Part-II">Algorithms: Part II</h2>
<ul>
<li><a href="/algorithms-2/week-1/index.html">Week 1 - Undirected Graph &amp; Directed Graph</a></li>
<li><a href="/algorithms-2/week-2/index.html">Week 2 - Minimum Spanning Trees &amp; Shortest Path</a></li>
<li><a href="/algorithms-2/week-3/index.html">Week 3 - Maximum Flow and Minimum Cut &amp; String Sort</a></li>
<li><a href="/algorithms-2/week-4/index.html">Week 4 - Tries &amp; Substring Search</a></li>
<li><a href="/algorithms-2/week-5/index.html">Week 5 - Regular Expressions</a></li>
<li><a href="/algorithms-2/week-6/index.html">Week 6 - Reductions</a></li>
</ul>
<h2 id="Algorithms-Part-I">Algorithms: Part I</h2>
<ul>
<li><a href="/algorithms-1/week-1/index.html">Week 1 - Union-Find &amp; Analysis of Algorithms</a></li>
<li><a href="/algorithms-1/week-2/index.html">Week 2 - Stacks and Queues &amp; Elementary Sorts</a></li>
<li><a href="/algorithms-1/week-3/index.html">Week 3 - Mergesort &amp; Quicksort</a></li>
<li><a href="/algorithms-1/week-4/index.html">Week 4 - Priority Queues &amp; Elementary Symbols</a></li>
<li><a href="/algorithms-1/week-5/index.html">Week 5 - Balanced Search Trees</a></li>
<li><a href="/algorithms-1/week-6/index.html">Week 6 - Hash Tables</a></li>
</ul>
<h2 id="Introduction-to-Software-Design-and-Architecture">Introduction to Software Design and Architecture</h2>
<ul>
<li><a href="/introduction-to-software-design-and-architecture/design-pattern/index.html">Design Pattern</a></li>
</ul>
<h2 id="Calculus-Two-Sequences-and-Series">Calculus Two: Sequences and Series</h2>
<ul>
<li><a href="/calculus-two/week-1/index.html">Week 1 - Sequences</a></li>
<li><a href="/calculus-two/week-2/index.html">Week 2 - Series</a></li>
<li><a href="/calculus-two/week-3/index.html">Week 3 - Convergence Tests</a></li>
<li><a href="/calculus-two/week-4/index.html">Week 4 - Alternating Series</a></li>
<li><a href="/calculus-two/week-5/index.html">Week 5 - Power Series</a></li>
<li><a href="/calculus-two/week-6/index.html">Week 6 - Taylor Series</a></li>
</ul>
<h2 id="LAFF-Linear-Algebra">LAFF Linear Algebra</h2>
<ul>
<li><a href="/laff-linear-algebra/week-1/index.html">Week 1 - Vectors in Linear Algebra</a></li>
<li><a href="/laff-linear-algebra/week-2/index.html">Week 2 - Linear Transformations and Matrices</a></li>
<li><a href="/laff-linear-algebra/week-3/index.html">Week 3 - Matrix-Vector Operations</a></li>
<li><a href="/laff-linear-algebra/week-4/index.html">Week 4 - Matrix-Vector to Matrix-Matrix Multiplication</a></li>
<li><a href="/laff-linear-algebra/week-5/index.html">Week 5 - Matrix- Matrix Multiplication</a></li>
<li><a href="/laff-linear-algebra/week-6/index.html">Week 6 - Gaussian Elimination</a></li>
<li><a href="/laff-linear-algebra/week-7/index.html">Week 7 - More Gaussian Elimination and Matrix Inversion</a></li>
<li><a href="/laff-linear-algebra/week-8/index.html">Week 8 - More on Matrix Inversion</a></li>
<li><a href="/laff-linear-algebra/week-9/index.html">Week 9 - Vector Spaces</a></li>
<li><a href="/laff-linear-algebra/week-10/index.html">Week 10 - Vector Spaces, Orthogonality, and Linear Least-Squares</a></li>
<li><a href="/laff-linear-algebra/week-11/index.html">Week 11 - Orthogonal Projection, Low Rank Approximation, and Orthogonal Bases</a></li>
<li><a href="/laff-linear-algebra/week-12/index.html">Week 12 - Eigenvalues and Eigenvectors</a></li>
</ul>
<h2 id="Stanford-Machine-Learning">Stanford Machine Learning</h2>
<ul>
<li><a href="/stanford-machine-learning/week-1/index.html">Week 1 - Introduction</a></li>
<li><a href="/stanford-machine-learning/week-2/index.html">Week 2 - Linear Regression with Multiple Variables</a></li>
<li><a href="/stanford-machine-learning/week-3/index.html">Week 3 - Logistic Regression &amp; Regularization</a></li>
<li><a href="/stanford-machine-learning/week-4/index.html">Week 4 - Neural Networks: Representation</a></li>
<li><a href="/stanford-machine-learning/week-5/index.html">Week 5 - Neural Networks: Learning</a></li>
<li><a href="/stanford-machine-learning/week-6a/index.html">Week 6a - Advice for Applying Machine Learning</a></li>
<li><a href="/stanford-machine-learning/week-6b/index.html">Week 6b - Machine Learning System Design</a></li>
<li><a href="/stanford-machine-learning/week-7/index.html">Week 7 - Support Vector Machines</a></li>
<li><a href="/stanford-machine-learning/week-8/index.html">Week 8 - Unsupervised Learning &amp; Dimensionality Reduction</a></li>
<li><a href="/stanford-machine-learning/week-9a/index.html">Week 9a - Anomaly Detection</a></li>
<li><a href="/stanford-machine-learning/week-9b/index.html">Week 9b - Recommender Systems</a></li>
<li><a href="/stanford-machine-learning/week-10/index.html">Week 10 - Large Scale Machine Learning</a></li>
<li><a href="/stanford-machine-learning/week-11/index.html">Week 11 - Application Example: Photo OCR</a></li>
</ul>
<h2 id="Calculus-One">Calculus One</h2>
<ul>
<li><a href="/calculus-one/week-2-3/index.html">Week 2-3 - Functions &amp; Limits</a></li>
<li><a href="/calculus-one/week-4/index.html">Week 4 - The Beginning of Derivatives</a></li>
<li><a href="/calculus-one/week-5/index.html">Week 5 - Techniques of Differentiation</a></li>
<li><a href="/calculus-one/week-6/index.html">Week 6 - Chain Rule</a></li>
<li><a href="/calculus-one/week-7/index.html">Week 7 - Derivatives of Trigonometric Functions</a></li>
<li><a href="/calculus-one/week-8/index.html">Week 8 - Derivatives in the Real World</a></li>
<li><a href="/calculus-one/week-9/index.html">Week 9 - Optimization</a></li>
<li><a href="/calculus-one/week-10/index.html">Week 10 - Linear Approximation</a></li>
<li><a href="/calculus-one/week-11-12/index.html">Week 11-12 - Antidifferentiation &amp; Integration</a></li>
<li><a href="/calculus-one/week-13/index.html">Week 13 - Fundamental Theorem of Calculus</a></li>
<li><a href="/calculus-one/week-14/index.html">Week 14 - Substitution Rule</a></li>
<li><a href="/calculus-one/week-15/index.html">Week 15 - Techniques of Integration</a></li>
<li><a href="/calculus-one/week-16/index.html">Week 16 - Applications of Integration</a></li>
</ul>
<h2 id="Computational-Thinking">Computational Thinking</h2>
<ul>
<li><a href="/computational-thinking/lecture-1/index.html">Lecture 1 - Optimization and Knapsack Problem</a></li>
<li><a href="/computational-thinking/lecture-2/index.html">Lecture 2 - Decision Trees and Dynamic Programming</a>
<ul>
<li><a href="/computational-thinking/lecture-2-powerset/index.html">Exercise: Power Set Function</a></li>
</ul>
</li>
<li><a href="/computational-thinking/lecture-3/index.html">Lecture 3 - Graphs</a></li>
<li><a href="/computational-thinking/lecture-4-5/index.html">Lecture 4-5 - Plotting</a></li>
<li><a href="/computational-thinking/lecture-6-7/index.html">Lecture 6-7 - Stochastic Programs &amp; Inferential Statistics</a></li>
<li><a href="/computational-thinking/lecture-8/index.html">Lecture 8 - Monte Carlo Simulation</a></li>
<li><a href="/computational-thinking/lecture-9/index.html">Lecture 9 - Sampling and Standard Error</a></li>
<li><a href="/computational-thinking/lecture-10-11/index.html">Lecture 10-11 - Experimental Data</a></li>
<li><a href="/computational-thinking/lecture-12/index.html">Lecture 12 - Machine Learning</a></li>
<li><a href="/computational-thinking/lecture-13/index.html">Lecture 13 - Statistical Abuses</a></li>
</ul>
<h2 id="Effective-Thinking-Through-Mathematics">Effective Thinking Through Mathematics</h2>
<ul>
<li><a href="/effective-thinking-through-mathematics/note/index.html">Note</a></li>
<li><a href="/effective-thinking-through-mathematics/week-4-telling-the-story-of-infinity/index.html">Week 4 (/Telling the Story of Infinity)</a></li>
<li><a href="/effective-thinking-through-mathematics/week-5-telling-the-story-of-the-euler-circuit-theorem/index.html">Week 5 (/Telling the Story of Euler Circuit Theorem)</a></li>
</ul>
<h2 id="CS50-Introduction-to-Computer-Science">CS50 Introduction to Computer Science</h2>
<ul>
<li><a href="/cs50/week-1/index.html">Week 1 - C</a></li>
<li><a href="/cs50/week-2/index.html">Week 2 - Arrays</a></li>
<li><a href="/cs50/week-3/index.html">Week 3 - Algorithms</a></li>
<li><a href="/cs50/week-4/index.html">Week 4 - Memory</a></li>
<li><a href="/cs50/week-5/index.html">Week 5 - Data Structures</a></li>
<li><a href="/cs50/week-6/index.html">Week 6 - HTTP</a></li>
<li><a href="/cs50/week-7-10/index.html">Week 7-10 - Machine Learning/Python/SQL/Javascript</a></li>
</ul>
<h2 id="Others">Others</h2>
<ul>
<li><a href="/symbols/index.html">Symbols of Mathematics</a></li>
<li><a href="/glossary/index.html">Glossary</a></li>
</ul>
<h2 id="About-Me"><a target="_blank" rel="noopener" href="https://ericyy.me/about/">About Me</a></h2>

</div>


<script src="/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <h1>P3L6: Virtualization</h1>
<!-- toc -->
<ul>
<li><a href="#what-is-virtualization">What is Virtualization?</a>
<ul>
<li><a href="#defining-virtualization">Defining Virtualization</a></li>
<li><a href="#benefits-of-virtualization">Benefits of Virtualization</a></li>
</ul>
</li>
<li><a href="#virtualization-models">Virtualization Models</a>
<ul>
<li><a href="#bare-metal-or-hypervisor-based">Bare Metal or Hypervisor-based</a></li>
<li><a href="#hosted">Hosted</a></li>
</ul>
</li>
<li><a href="#hardware-protection-levels">Hardware Protection Levels</a></li>
<li><a href="#processor-virtualization">Processor Virtualization</a>
<ul>
<li><a href="#problems-with-trap-and-emulate">Problems with Trap-and-Emulate</a></li>
</ul>
</li>
<li><a href="#memory-virtualization">Memory Virtualization</a>
<ul>
<li><a href="#full-virtualization">Full Virtualization</a></li>
<li><a href="#paravirtualization">Paravirtualization</a></li>
</ul>
</li>
<li><a href="#device-virtualization">Device Virtualization</a>
<ul>
<li><a href="#passthrough-model">Passthrough Model</a></li>
<li><a href="#hypervisor-direct-model">Hypervisor Direct Model</a></li>
<li><a href="#split-device-driver-model">Split Device Driver Model</a></li>
</ul>
</li>
<li><a href="#hardware-virtualization">Hardware Virtualization</a>
<ul>
<li><a href="#x86-vt-revolution">x86 VT Revolution</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<hr>
<h2 id="What-is-Virtualization">What is Virtualization?</h2>
<p>Virtualization allows concurrent executions of multiple OSs(and their applications) on the same physical machine.</p>
<ul>
<li>virtual resources = each OS thinks that it “owns” hardware resources</li>
<li>virtual machines(VM) = OS + applications + virtual resources(guest domain)</li>
<li>virtualization layer = management of physical hardware (virtual machine monitor, hypervisor)</li>
</ul>
<img src="https://i.imgur.com/QlVBYcB.jpg" style="width: 400px" />
<h3 id="Defining-Virtualization">Defining Virtualization</h3>
<p>A virtual machine is an <strong>efficient</strong>, <strong>isolated duplicate</strong> of a real machine.</p>
<ul>
<li>for example, virtual box is a virtualization, but java virtual machine and gameboy emulator are not, because they are very different from the platform they are running.</li>
</ul>
<p>Virtualization is supported by the <strong>virtual machine monitor (VMM)</strong>. The VMM has three responsibilities.</p>
<p>First, the VMM must <strong>provide an environment that is essentially identical to the original machine</strong>. The capacity may differ, but the overall setup (type of CPU, types of devices) should be the same. The VMM must provide some fidelity that the representation of the hardware that is visible to the VM matches the hardware that is available on the physical platform.</p>
<p>Second, <strong>programs that run in VMs must show at worst only minor decreases in speed</strong>. Clearly, the VMs are only given a portion of the resources available to the host machine. However, the goal of the VMM is to ensure that the VM would perform at the same speed as a native application if it were given all of the host’s resources. The VMM must provide performance to the VMs that is as close to native performance as possible.</p>
<p>Finally, the VMM is in complete control of the system resources. The VMM controls who access which resources and when, and it can be relied upon to provide <strong>safety</strong> and <strong>isolation</strong> among the VMs.</p>
<h3 id="Benefits-of-Virtualization">Benefits of  Virtualization</h3>
<ol>
<li>Consolidation - run multiple VMs on a single physical platform.
<ol>
<li>decrease cost and improve manageability</li>
</ol>
</li>
<li>Migration - since VMs are isolated, they can be easy to setup, teardown and clone virtual machine.
<ol>
<li>high availability, reliability</li>
</ol>
</li>
<li>security, debugging, support for legacy OSs</li>
</ol>
<h2 id="Virtualization-Models">Virtualization Models</h2>
<p><a target="_blank" rel="noopener" href="https://www.ibm.com/cloud/learn/virtualization-a-complete-guide">https://www.ibm.com/cloud/learn/virtualization-a-complete-guide</a></p>
<h3 id="Bare-Metal-or-Hypervisor-based">Bare Metal or Hypervisor-based</h3>
<p>In bare-metal virtualization (also known as <strong>hypervisor-based or type 1 virtualization</strong>, the VMM manages all the hardware resources and support execution of VMs.</p>
<img src="https://i.imgur.com/xcu9ucW.jpg" style="width: 400px" />
<p>The privileged VM runs all of the device drivers and controls how the devices on the platform are used. And it will run some other configuration and management tasks to further assist the hypervisor.</p>
<p>This model is adapted by the <strong>Xen</strong> virtualization software and by the <strong>ESX</strong> hypervisor from VMware.</p>
<p>Regarding Xen, the VMs that run in the virtualized environment are referred to as domains. The privileged domain is referred to as <strong>dom0</strong> and the guest domains are referred to as <strong>domUs</strong>. Xen is the hypervisor. All of the device drivers are running in dom0.</p>
<p>VMware maintains the largest share of server cores. VMware has been able to mandate that device manufactures develop drivers that can be used by the hypervisor. Since VMware targets servers, there are relatively few devices. To support the open source community, VMware has many open source APIs.</p>
<p>VMware used to have a control core based in Linux (similar to the dom0 in Xen), but now all of the configuration is done via remote APIs.</p>
<h3 id="Hosted">Hosted</h3>
<p>The other type of virtualization model is the <strong>hosted (or type 2)</strong> model.</p>
<img src="https://i.imgur.com/vAqdAD1.jpg" style="width: 600px" />
<p>In this model, there is a full-fledged host OS that manages all of the hardware resources. The host OS integrates a VMM, which is responsible for providing the VMs with their virtual platform interface.</p>
<p>As necessary, the VMM module will invoke devices drivers and other host components as needed.</p>
<p>One benefit of this model is that it can leverage all of the services and mechanisms that are already developed for the host operating system. Much less functionality needs to be developed for the VMM module itself.</p>
<p>In this setup, you can run guest VMs through the VMM module as well as native applications directly on the host OS.</p>
<p>One example of the hosted model is <strong>kernel-based VM (KVM)</strong> which is built into Linux. The Linux host provides all aspects of the physical hardware management and can run regular Linux applications directly.</p>
<p>The support for running guest VMs comes from a combination of the KVM (VMM) module and a hardware emulator called <strong>QEMU</strong>.</p>
<p>QEMU is used in as a virtual interface between the VM and the physical hardware, and only intervenes during certain type of critical instructions; for example, I/O management.</p>
<p>KVM has been able to leverage all of the advances that have been contributed to the Linux open source community. Because of this KVM can quickly adapt to new features and fixes.</p>
<h2 id="Hardware-Protection-Levels">Hardware Protection Levels</h2>
<p>Commodity hardware has more than two protection levels. For example, x86 architecture has four <strong>protection levels</strong>, called <strong>rings</strong>.</p>
<p>Ring 0 has the highest privilege and can access all resources and execute all hardware-supported instructions. In a native model, the operating system resides at ring 0.</p>
<p>In contrast, ring 3 has the least privilege. This is where the applications reside. Whenever an application tries to perform some operation for which it does not have privilege, a trap will be caused and control will be switched to ring 0.</p>
<p>In virtualization setups, the hypervisor sits in ring 0, pushing the OS to ring 1. The applications remain at ring 3.</p>
<p>More recent x86 architectures introduce <strong>two different protection modes</strong>: <strong>root and non-root</strong>. Within each mode, the four rings exist.</p>
<p>When running in root mode, everything is permitted. The hypervisor resides in ring 0 of the root mode. In contrast, in non-root mode, certain types of operations are not permitted. Guest VMs operate in non-root mode, with their applications in ring 3 of this mode, and their OS in ring 0.</p>
<p>Attempts by the guest OS to perform privileged operations cause traps called <strong>VMExits</strong>, which trigger a switch to root mode, passing control to the hypervisor. When the hypervisor completes its operation, it passes control back to the virtual machine, by performing a <strong>VMEntry</strong>, which switches out of root mode.</p>
<h2 id="Processor-Virtualization">Processor Virtualization</h2>
<p>Guest instructions are executed directly by the hardware. The VMM does not interfere with every instruction that is issued by the guest OS or its applications.</p>
<p>As long as the guest OS is operating within the resources allocated to it by the hypervisor, the instructions will operate at hardware speeds, which will underline the efficiency of the virtualization solution.</p>
<p>Whenever a privileged instruction is issued, the processor causes a trap to the hypervisor. At this point, the hypervisor can determine if the operation is to be allowed or not. If the operation is illegal, the hypervisor can perform some punitive action, like shutting down the VM. If the operation should be allowed, the hypervisor must provide the necessary emulation to ensure that the guest OS receives the response it was expecting from the hardware. This is known as the <strong>trap-and-emulate</strong> strategy.</p>
<p>The hypervisor intervention must be invisible to the guest OS.</p>
<h3 id="Problems-with-Trap-and-Emulate">Problems with Trap-and-Emulate</h3>
<ul>
<li>x86 Virtualization in the Past - pre 2005
<ul>
<li>Before 2005, x86 platforms had only the four privilege rings, without the root/non-root distinction. Hypervisor in ring 0, and the guest operating system in ring 1.</li>
<li>However, there were exactly <strong>17 hardware instructions that were privileged (required ring 0), but didn’t cause a trap.</strong> Issuing them from another protection level wouldn’t pass control to the hypervisor, but would just fail silently.</li>
<li>For example, enabling/disabling interrupts requires manipulating a bit in a privileged register, which can be done with the POPF/PUSHF instructions. When these instructions were issued, they just failed silently.</li>
<li>Since control isn’t passed to the hypervisor, the hypervisor has no idea that the OS wanted to change the interrupt status, so it cannot emulate that behavior.</li>
<li>At the same time, since the failure was silent, the OS doesn’t know about it and assumes the change was successful. As a result, it continues with its execution.</li>
</ul>
</li>
<li>One solution to solve the issue of  17 hardware instructions was to rewrite the VM binary. This process is called <strong>binary translation</strong>. – VMWare
<ul>
<li>The goal is to not install any additional software or modify the guest OS in order to run it a virtualized environment.
<ul>
<li>When the guest OS is not modified, this type of virtualization is called <strong>full virtualization</strong>.</li>
</ul>
</li>
<li>Approach: <strong>dynamic binary translation</strong> – capture the execution during the runtime to determine
<ol>
<li>inspect code blocks to be executed to see if any of the 17 hardware instructions are present.</li>
<li>if it is, translate to alternate instruction sequence
<ul>
<li>e.g., to emulate desired behavior, possibly even avoiding trap</li>
</ul>
</li>
<li>otherwise, run at hardware speeds
<ul>
<li>cache translated blocks to amortize translation costs</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>Another approach, gives up unmodified guest OS, which is called <strong>paravirtualization</strong>. – Xen
<ul>
<li>The guest OS running in virtualized environment on top of a hypervisor as oppose to hardware directly.</li>
<li>A paravirtualized guest OS may not directly try to perform operations that it knows will fail, but will instead make explicit calls to the hypervisor to achieve the desired behavior.
<ul>
<li>These calls are called <strong>hypercalls</strong> and they behave similar to system calls. The hypercall will trap to the hypervisor which, upon performing the required operation with the data supplied by the guest, will pass control back to the guest.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Memory-Virtualization">Memory Virtualization</h2>
<h3 id="Full-Virtualization">Full Virtualization</h3>
<p>All guests expect contiguous physical memory, starting at 0. To achieve this, we need to distinguish three types of addresses: <strong>virtual addresses</strong>, <strong>physical addresses</strong> and <strong>machines addresses</strong>.</p>
<ul>
<li>Virtual addresses are used by the applications in the guest.</li>
<li>Physical addresses are used by the kernel of the guest which think it owns.</li>
<li>Machine address correspond to the physical addresses on the underlying physical platform.<br>
In effect, there are two ways to mapping page tables:</li>
</ul>
<ol>
<li>guest page table: virtual address -&gt; physical address; hypervisor: physical address -&gt; machine address
<ul>
<li>it’s too expensive due to the overhead of extra memory references.</li>
</ul>
</li>
<li>guest page tables: <strong>virtual address -&gt; physical address</strong>; hypervisor <strong>shadow page table</strong>: <strong>virtual address -&gt; machine address</strong>
<ul>
<li>hypervisor needs to maintain the consistence between the two page tables.
<ul>
<li>e.g. invalidate on context switch write-protect guest PT to track new mappings</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Paravirtualization">Paravirtualization</h3>
<p>In paravirtualization, guests are aware of the virtualization, so no longer strict requirement on contiguous physical memory starting at 0. The guest OS can explicitly registers page tables with hypervisor, so there is no need for two page tables.</p>
<p>The guest still doesn’t have write permissions to this page table - which is now used directly by the hardware - as this would allow as guest to potentially corrupt another guest by overwriting its memory.</p>
<p>Because of this, every write to the page table will cause a trap to the hypervisor. However, since the guest is paravirtualized, we can modify the guest to batch page table updates into a single hypercall, amortizing the cost of the VM exit across multiple updates.</p>
<p>Many of the overheads associated with memory virtualization in both full and paravirtualization have been reduced by improvements on newer hardware platforms.</p>
<h2 id="Device-Virtualization">Device Virtualization</h2>
<p>When we talk about CPU/Memory virtualization, certain things are relatively less complicated because there is a significant level of standardization at the <strong>instruction set architecture (ISA)</strong> level across different platforms.</p>
<p>From a virtualization standpoint, we know that we have to support a specific ISA and we don’t care if there are lower level differences between the hardware because it is up to the hardware manufacturers to be standardized at the ISA level.</p>
<p>This is the case for a specific ISA like x86.</p>
<p>When we look at devices, there is a much greater diversity in the type of devices. Also, there is a lack of standardization when it comes to the specifics of the device interface and the semantics of that interface.</p>
<p>To deal with this diversity, virtualization solutions adapt one of three key models to virtualize devices.</p>
<h3 id="Passthrough-Model">Passthrough Model</h3>
<img src="https://i.imgur.com/WdqCDuP.jpg" style="width: 400px" />
<p>In the passthrough model, the VMM-level driver is responsible for configuring the access permissions to a device. For example, it will allow a guest VM to have access to the memory registers corresponding to a device.</p>
<p>In this approach, the guest VM has exclusive access to a device. In addition, the VM can directly access the device, without interacting with the VMM. This model is also called the <strong>VMM-bypass model</strong>.</p>
<p>The problem with this exclusive access is that is making sharing devices across VMs difficult. The hypervisor will need to continuously reassign who the device belongs to over time, and device access will not happen concurrently across VMs. This is often unfeasible.</p>
<p>Because the hypervisor is completely out of the way, the guest VM and the device driver in the guest VM directly operate on and control the device. This means that there needs to be a device of the exact same type on the physical platform that the guest OS expects.</p>
<p>One of the benefits of virtualization is that the guest VMs are decoupled from the physical hardware, which makes migration of guests across physical nodes easy.</p>
<p>This passthrough model breaks that decoupling as it binds a device to a VM. This reintroduces migration complexity as there may be some device specific/resident state that would need to be properly copied and configured to a destination mode.</p>
<h3 id="Hypervisor-Direct-Model">Hypervisor Direct Model</h3>
<img src="https://i.imgur.com/ojEat74.jpg" style="width: 400px" />
<p>In the hypervisor-direct model, <u>the hypervisor intercepts every device access request that is performed by the guest VM</u>.</p>
<p>The hypervisor no longer has the constraint that the requested device and the physical device match.</p>
<p>Instead, the hypervisor can translate the device access request to some generic representation of an I/O operation for that particular family of devices - network or disk, for example - and then traverse the hypervisor resident I/O stack. The bottom of that stack is the actual real device driver, which the hypervisor will finally invoke to fulfill the request.</p>
<p>A key benefit of this approach is that the VM remains decoupled from the physical platform/device. As a result, migration remains easy. In addition, device sharing can now occur since device access is managed by the hypervisor.</p>
<p>The downside of the model is that the device emulation step adds latency to device accesses. As well, this model requires that the hypervisor supports all of the drivers so it can perform the necessary emulations, which means that the hypervisor is now exposed to all of the complexities and complications of various device drivers.</p>
<h3 id="Split-Device-Driver-Model">Split Device Driver Model</h3>
<img src="https://i.imgur.com/AB94qjr.jpg" style="width: 400px" />
<p>In the split device driver model, all of the devices accesses are controlled in a way that involves a component that resides in a guest VM and a component that resides in a hypervisor layer.</p>
<p>The front-end driver resides in the guest VM and the actual driver for the physical device - the back-end driver - resides in the service VM (or the host in type 2 virtualization).</p>
<p>Although the back-end driver doesn’t necessarily have to be modified, as it is the same driver that the OS would use as if it were running natively, the front-end driver does need to be modified.</p>
<p>The front-end driver needs to take the device operations that are made by the applications in the guest, and then wrap them in a standard format to be delivered to the back-end component. Because of this modification, this model can only really be used in paravirtualized guests.</p>
<p>One benefit of this approach is that the device emulation overhead can be eliminated. Another benefit of this approach is that the centralized back-end component allows for better management of shared devices.</p>
<h2 id="Hardware-Virtualization">Hardware Virtualization</h2>
<p>In the x86 world, the two virtualization-friendly architectures are the AMD Pacifica architecture and the Intel Vanderpool Technology architecture, both created circa 2005.</p>
<p>One of the first things that was fixed was to close the holes with the 17 non-virtualizable hardware instructions so that they will cause a trap and pass control over to the hypervisor in privileged mode.</p>
<p>Also, the new protection mode was introduced. Now, there was a “root” and “non-root” mode (also known as “host” and “guest”, respectively).</p>
<p>Support was added for the hardware processor to interpret the state of the virtual processors (or vCPUs). This information is captured in a VM control block. The hardware understands how to “walk” this data structure, and can specify whether or not a system call should trap.</p>
<p>Once hardware was able to detect the presence of different VMs, the next step was to tag the memory structures used by the hypervisor with the different VM identifiers.</p>
<p>This led to support for extended page tables and tagged TLBs, both of which incorporated VM identifiers. This makes context switches by VMs (also called world switches) more efficient, because the page tables and TLBs no longer had to be flushed.</p>
<p>Hardware was also extended to add better support for I/O virtualization, which included modifications to the processor and chipset. Some examples of these extensions were multiqueue devices (think of a single devices having multiple logical interfaces that can be used by multiple VMs) as well as better interrupt routing so that the core on which the VM is running is actually the core that gets interrupted.</p>
<p>Other features were added for better security and management support.</p>
<p>Finally, a number of new instructions were added to x86 in order to implement these new features. For example, a new instruction was added to allow switching into new protection mode.</p>
<h3 id="x86-VT-Revolution">x86 VT Revolution</h3>
<img src="https://i.imgur.com/u9YEBDa.jpg" style="width: 800px" />

</div>


  <div class="book-comments">
    




  </div>



<script src="/js/book-post.js"></script>


<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.js" integrity="sha384-97gW6UIJxnlKemYavrqDHSX3SiygeOwIZhwyOKRfSaf0JWKRVj9hLASHgFTzT+0O" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">
  
  <div class="divider"></div>
</div>

  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/js/book-toc.js"></script>

</div>

      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/js/book.js"></script>

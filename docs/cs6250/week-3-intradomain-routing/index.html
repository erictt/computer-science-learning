<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          Eric&#39;s CS Notes
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 6.1.0"></head>


<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>ERIC&#39;S CS NOTES</span>
  </a>
</div>

    <div class="book-menu">
  <!--
## Introduction to Probability

* [Unit 1: Probability models and axioms](/introduction-to-probability/unit-1/index.html)
* [Unit 2: Conditioning and independence](/introduction-to-probability/unit-2/index.html)
* [Unit 3: Counting](/introduction-to-probability/unit-3/index.html)
* [Unit 4: Discrete random variables](/introduction-to-probability/unit-4/index.html)
* [Unit 5: Continuous random variables](/introduction-to-probability/unit-5/index.html)
* [Unit 6: Further topics on random variables](/introduction-to-probability/unit-6/index.html)
* [Unit 7: Bayesian inference](/introduction-to-probability/unit-7/index.html)
* [Unit 8: Limit theorems and classical statistics](/introduction-to-probability/unit-8/index.html)
* [Unit 9: Bernoulli and Poisson processes](/introduction-to-probability/unit-9/index.html)
* [Unit 10: Markov chains](/introduction-to-probability/unit-10/index.html)
-->
<!--
## Multivariable Calculus

* [Unit 1: Thinking about multivariable functions](/multivariable-calculus/unit-1/index.html)
* [Unit 2: Derivatives of multivariable functions](/multivariable-calculus/unit-2/index.html)

* [Unit 3: Applications of multivariable derivatives](/multivariable-calculus/unit-3/index.html)
* [Unit 4: Integrating multivariable functions](/multivariable-calculus/unit-4/index.html)
* [Unit 5: Green's, Stokes', and the divergence theorems](/multivariable-calculus/unit-5/index.html)
-->
<h2 id="cs6250-computer-networks"><a class="markdownIt-Anchor" href="#cs6250-computer-networks"></a> CS6250 Computer Networks</h2>
<ul>
<li><a href="/cs6250/week-1-internet-architecture/index.html">Week 1 - Internet Architecture</a></li>
<li><a href="/cs6250/week-2-transport-and-application-layers/index.html">Week 2 - Transport and Application Layers</a></li>
<li><a href="/cs6250/week-3-intradomain-routing/index.html">Week 3 - Intradomain Routing</a></li>
<li><a href="/cs6250/week-4-as-relationships-and-interdomain-routing/index.html">Week 4 - AS Relationships and Interdomain Routing</a></li>
<li><a href="/cs6250/week-5-router-design-and-algorithems-part-1/index.html">Week 5 - Router Design and Algorithms Part 1</a></li>
</ul>
<!--
* [Week 6 - Router Design and Algorithms Part 2](/cs6250/week-6-router-design-and-algorithems-part-2/index.html)
-->
<h2 id="cs6200-graduate-introduction-to-operating-systems"><a class="markdownIt-Anchor" href="#cs6200-graduate-introduction-to-operating-systems"></a> CS6200 Graduate Introduction to Operating Systems</h2>
<ul>
<li><a href="/cs6200/p1-preparation/index.html">P0 - Preparation</a></li>
<li><a href="/cs6200/p1l2-introduction/index.html">P1L2 - Introduction</a></li>
<li><a href="/cs6200/p2l1-processes-and-process-management/index.html">P2L1 - Processes and Process Management</a></li>
<li><a href="/cs6200/p2l2-threads-and-concurrency/index.html">P2L2 - Threads and Concurrency</a></li>
<li><a href="/cs6200/p2l3-pthread/index.html">P2L3 - PThread</a></li>
<li><a href="/cs6200/p2l4-thread-design-consideration/index.html">P2L4 - Thread Design Considerations</a></li>
</ul>
<!--
* [P2L5 - Thread Performance Considerations](/cs6200/p2l5-thread-performance-consideration/index.html)
-->
<h2 id="algorithms-part-ii"><a class="markdownIt-Anchor" href="#algorithms-part-ii"></a> Algorithms: Part II</h2>
<ul>
<li><a href="/algorithms-2/week-1/index.html">Week 1 - Undirected Graph &amp; Directed Graph</a></li>
<li><a href="/algorithms-2/week-2/index.html">Week 2 - Minimum Spanning Trees &amp; Shortest Path</a></li>
<li><a href="/algorithms-2/week-3/index.html">Week 3 - Maximum Flow and Minimum Cut &amp; String Sort</a></li>
<li><a href="/algorithms-2/week-4/index.html">Week 4 - Tries &amp; Substring Search</a></li>
<li><a href="/algorithms-2/week-5/index.html">Week 5 - Regular Expressions</a></li>
<li><a href="/algorithms-2/week-6/index.html">Week 6 - Reductions</a></li>
</ul>
<h2 id="algorithms-part-i"><a class="markdownIt-Anchor" href="#algorithms-part-i"></a> Algorithms: Part I</h2>
<ul>
<li><a href="/algorithms-1/week-1/index.html">Week 1 - Union-Find &amp; Analysis of Algorithms</a></li>
<li><a href="/algorithms-1/week-2/index.html">Week 2 - Stacks and Queues &amp; Elementary Sorts</a></li>
<li><a href="/algorithms-1/week-3/index.html">Week 3 - Mergesort &amp; Quicksort</a></li>
<li><a href="/algorithms-1/week-4/index.html">Week 4 - Priority Queues &amp; Elementary Symbols</a></li>
<li><a href="/algorithms-1/week-5/index.html">Week 5 - Balanced Search Trees</a></li>
<li><a href="/algorithms-1/week-6/index.html">Week 6 - Hash Tables</a></li>
</ul>
<h2 id="introduction-to-software-design-and-architecture"><a class="markdownIt-Anchor" href="#introduction-to-software-design-and-architecture"></a> Introduction to Software Design and Architecture</h2>
<ul>
<li><a href="/introduction-to-software-design-and-architecture/design-pattern/index.html">Design Pattern</a></li>
</ul>
<h2 id="calculus-two-sequences-and-series"><a class="markdownIt-Anchor" href="#calculus-two-sequences-and-series"></a> Calculus Two: Sequences and Series</h2>
<ul>
<li><a href="/calculus-two/week-1/index.html">Week 1 - Sequences</a></li>
<li><a href="/calculus-two/week-2/index.html">Week 2 - Series</a></li>
<li><a href="/calculus-two/week-3/index.html">Week 3 - Convergence Tests</a></li>
<li><a href="/calculus-two/week-4/index.html">Week 4 - Alternating Series</a></li>
<li><a href="/calculus-two/week-5/index.html">Week 5 - Power Series</a></li>
<li><a href="/calculus-two/week-6/index.html">Week 6 - Taylor Series</a></li>
</ul>
<h2 id="laff-linear-algebra"><a class="markdownIt-Anchor" href="#laff-linear-algebra"></a> LAFF Linear Algebra</h2>
<ul>
<li><a href="/laff-linear-algebra/week-1/index.html">Week 1 - Vectors in Linear Algebra</a></li>
<li><a href="/laff-linear-algebra/week-2/index.html">Week 2 - Linear Transformations and Matrices</a></li>
<li><a href="/laff-linear-algebra/week-3/index.html">Week 3 - Matrix-Vector Operations</a></li>
<li><a href="/laff-linear-algebra/week-4/index.html">Week 4 - Matrix-Vector to Matrix-Matrix Multiplication</a></li>
<li><a href="/laff-linear-algebra/week-5/index.html">Week 5 - Matrix- Matrix Multiplication</a></li>
<li><a href="/laff-linear-algebra/week-6/index.html">Week 6 - Gaussian Elimination</a></li>
<li><a href="/laff-linear-algebra/week-7/index.html">Week 7 - More Gaussian Elimination and Matrix Inversion</a></li>
<li><a href="/laff-linear-algebra/week-8/index.html">Week 8 - More on Matrix Inversion</a></li>
<li><a href="/laff-linear-algebra/week-9/index.html">Week 9 - Vector Spaces</a></li>
<li><a href="/laff-linear-algebra/week-10/index.html">Week 10 - Vector Spaces, Orthogonality, and Linear Least-Squares</a></li>
<li><a href="/laff-linear-algebra/week-11/index.html">Week 11 - Orthogonal Projection, Low Rank Approximation, and Orthogonal Bases</a></li>
<li><a href="/laff-linear-algebra/week-12/index.html">Week 12 - Eigenvalues and Eigenvectors</a></li>
</ul>
<h2 id="stanford-machine-learning"><a class="markdownIt-Anchor" href="#stanford-machine-learning"></a> Stanford Machine Learning</h2>
<ul>
<li><a href="/stanford-machine-learning/week-1/index.html">Week 1 - Introduction</a></li>
<li><a href="/stanford-machine-learning/week-2/index.html">Week 2 - Linear Regression with Multiple Variables</a></li>
<li><a href="/stanford-machine-learning/week-3/index.html">Week 3 - Logistic Regression &amp; Regularization</a></li>
<li><a href="/stanford-machine-learning/week-4/index.html">Week 4 - Neural Networks: Representation</a></li>
<li><a href="/stanford-machine-learning/week-5/index.html">Week 5 - Neural Networks: Learning</a></li>
<li><a href="/stanford-machine-learning/week-6a/index.html">Week 6a - Advice for Applying Machine Learning</a></li>
<li><a href="/stanford-machine-learning/week-6b/index.html">Week 6b - Machine Learning System Design</a></li>
<li><a href="/stanford-machine-learning/week-7/index.html">Week 7 - Support Vector Machines</a></li>
<li><a href="/stanford-machine-learning/week-8/index.html">Week 8 - Unsupervised Learning &amp; Dimensionality Reduction</a></li>
<li><a href="/stanford-machine-learning/week-9a/index.html">Week 9a - Anomaly Detection</a></li>
<li><a href="/stanford-machine-learning/week-9b/index.html">Week 9b - Recommender Systems</a></li>
<li><a href="/stanford-machine-learning/week-10/index.html">Week 10 - Large Scale Machine Learning</a></li>
<li><a href="/stanford-machine-learning/week-11/index.html">Week 11 - Application Example: Photo OCR</a></li>
</ul>
<h2 id="calculus-one"><a class="markdownIt-Anchor" href="#calculus-one"></a> Calculus One</h2>
<ul>
<li><a href="/calculus-one/week-2-3/index.html">Week 2-3 - Functions &amp; Limits</a></li>
<li><a href="/calculus-one/week-4/index.html">Week 4 - The Beginning of Derivatives</a></li>
<li><a href="/calculus-one/week-5/index.html">Week 5 - Techniques of Differentiation</a></li>
<li><a href="/calculus-one/week-6/index.html">Week 6 - Chain Rule</a></li>
<li><a href="/calculus-one/week-7/index.html">Week 7 - Derivatives of Trigonometric Functions</a></li>
<li><a href="/calculus-one/week-8/index.html">Week 8 - Derivatives in the Real World</a></li>
<li><a href="/calculus-one/week-9/index.html">Week 9 - Optimization</a></li>
<li><a href="/calculus-one/week-10/index.html">Week 10 - Linear Approximation</a></li>
<li><a href="/calculus-one/week-11-12/index.html">Week 11-12 - Antidifferentiation &amp; Integration</a></li>
<li><a href="/calculus-one/week-13/index.html">Week 13 - Fundamental Theorem of Calculus</a></li>
<li><a href="/calculus-one/week-14/index.html">Week 14 - Substitution Rule</a></li>
<li><a href="/calculus-one/week-15/index.html">Week 15 - Techniques of Integration</a></li>
<li><a href="/calculus-one/week-16/index.html">Week 16 - Applications of Integration</a></li>
</ul>
<h2 id="computational-thinking"><a class="markdownIt-Anchor" href="#computational-thinking"></a> Computational Thinking</h2>
<ul>
<li><a href="/computational-thinking/lecture-1/index.html">Lecture 1 - Optimization and Knapsack Problem</a></li>
<li><a href="/computational-thinking/lecture-2/index.html">Lecture 2 - Decision Trees and Dynamic Programming</a>
<ul>
<li><a href="/computational-thinking/lecture-2-powerset/index.html">Exercise: Power Set Function</a></li>
</ul>
</li>
<li><a href="/computational-thinking/lecture-3/index.html">Lecture 3 - Graphs</a></li>
<li><a href="/computational-thinking/lecture-4-5/index.html">Lecture 4-5 - Plotting</a></li>
<li><a href="/computational-thinking/lecture-6-7/index.html">Lecture 6-7 - Stochastic Programs &amp; Inferential Statistics</a></li>
<li><a href="/computational-thinking/lecture-8/index.html">Lecture 8 - Monte Carlo Simulation</a></li>
<li><a href="/computational-thinking/lecture-9/index.html">Lecture 9 - Sampling and Standard Error</a></li>
<li><a href="/computational-thinking/lecture-10-11/index.html">Lecture 10-11 - Experimental Data</a></li>
<li><a href="/computational-thinking/lecture-12/index.html">Lecture 12 - Machine Learning</a></li>
<li><a href="/computational-thinking/lecture-13/index.html">Lecture 13 - Statistical Abuses</a></li>
</ul>
<h2 id="effective-thinking-through-mathematics"><a class="markdownIt-Anchor" href="#effective-thinking-through-mathematics"></a> Effective Thinking Through Mathematics</h2>
<ul>
<li><a href="/effective-thinking-through-mathematics/note/index.html">Note</a></li>
<li><a href="/effective-thinking-through-mathematics/week-4-telling-the-story-of-infinity/index.html">Week 4 (/Telling the Story of Infinity)</a></li>
<li><a href="/effective-thinking-through-mathematics/week-5-telling-the-story-of-the-euler-circuit-theorem/index.html">Week 5 (/Telling the Story of Euler Circuit Theorem)</a></li>
</ul>
<h2 id="cs50-introduction-to-computer-science"><a class="markdownIt-Anchor" href="#cs50-introduction-to-computer-science"></a> CS50 Introduction to Computer Science</h2>
<ul>
<li><a href="/cs50/week-1/index.html">Week 1 - C</a></li>
<li><a href="/cs50/week-2/index.html">Week 2 - Arrays</a></li>
<li><a href="/cs50/week-3/index.html">Week 3 - Algorithms</a></li>
<li><a href="/cs50/week-4/index.html">Week 4 - Memory</a></li>
<li><a href="/cs50/week-5/index.html">Week 5 - Data Structures</a></li>
<li><a href="/cs50/week-6/index.html">Week 6 - HTTP</a></li>
<li><a href="/cs50/week-7-10/index.html">Week 7-10 - Machine Learning/Python/SQL/Javascript</a></li>
</ul>
<h2 id="others"><a class="markdownIt-Anchor" href="#others"></a> Others</h2>
<ul>
<li><a href="/symbols/index.html">Symbols of Mathematics</a></li>
<li><a href="/glossary/index.html">Glossary</a></li>
</ul>

</div>


<script src="/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <h1 id="lesson-3-intradomain-routing"><a class="markdownIt-Anchor" href="#lesson-3-intradomain-routing"></a> Lesson 3: Intradomain Routing</h1>
<!-- toc -->
<ul>
<li><a href="#routing-protocols">Routing Protocols</a>
<ul>
<li><a href="#the-link-state-algorithm">The Link-state Algorithm</a></li>
<li><a href="#the-distance-vector-algorithm">The Distance-vector Algorithm</a>
<ul>
<li><a href="#the-count-to-infinity-problem">The count-to-infinity problem</a></li>
<li><a href="#solution-to-the-count-to-infinity-problem-poison-reverse">Solution to the count-to-infinity problem: Poison reverse</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#internet-approach-to-scalable-routing">Internet approach to scalable routing</a>
<ul>
<li><a href="#routing-information-protocolrip">Routing Information Protocol(RIP)</a></li>
<li><a href="#open-shortest-path-first-ospf">Open Shortest Path First (OSPF)</a>
<ul>
<li><a href="#processing-ospf-messages-in-the-router">Processing OSPF Messages in the Router</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#hot-potato-routing">Hot Potato Routing</a></li>
<li><a href="#an-example-traffic-engineering-frameworkoptional">An Example Traffic Engineering Framework[Optional]</a></li>
</ul>
<!-- tocstop -->
<hr />
<p>This lecture, we learn about the protocols that enable data to travel over a “good” path from the source to the destination within a single administrative domain.</p>
<ul>
<li>
<p>Network-layer functions:</p>
<ul>
<li><strong>forwarding</strong>: move packets from router’s input to appropriate router output. &lt;-- data plane</li>
<li><strong>routing</strong>: move packets from router’s input to appropriate router output. &lt;-- control plane</li>
</ul>
</li>
<li>
<p>Two approaches to structuring network control plane:</p>
<ul>
<li><strong>per-router control (traditional) &lt;-- this lesson focus on</strong>
<ul>
<li>Individual routing algorithm components in each and every router interact in the control plane</li>
<li>
<img src="https://i.imgur.com/FjdfGIk.jpg" style="width: 500px" />
</li>
</ul>
</li>
<li>logically centralized control (software defined networking)
<ul>
<li>Remote controller computes, installs forwarding tables in routers</li>
<li>
<img src="https://i.imgur.com/1nAAdMr.jpg" style="width: 500px" />
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Two Types of Routing Domain</p>
<ul>
<li><strong>Intradomain routing</strong> (Interior Gateway Protocols (IGPs)): routers that belong to the same administrative domain &lt;-- this lesson focus on</li>
<li><strong>Interdomain routing</strong>: Routers belong to different administrative domains</li>
</ul>
</li>
</ul>
<h2 id="routing-protocols"><a class="markdownIt-Anchor" href="#routing-protocols"></a> Routing Protocols</h2>
<ul>
<li>
<p>Goal: determine the “good” paths(equivalently, routes), from sending hosts to receiving host, through network of routers</p>
<ul>
<li>path: sequence of routers packets traverse from given initial source host to final destination host</li>
<li>“good”: least “cost”, “fastest”, “least congested”</li>
<li>routing: a “top-10” networking challenge!</li>
</ul>
</li>
<li>
<p>Routing algorithm classification</p>
<ul>
<li>
<img src="https://i.imgur.com/WjPJvy3.jpg" style="width: 500px" />
</li>
</ul>
</li>
<li>
<p>Notation</p>
<ul>
<li><strong>u</strong> source node.</li>
<li><strong>v</strong> every other node.</li>
<li><strong>D(v)</strong> cost of the current least cost path from u to v.</li>
<li><strong>p(v)</strong> the previous node along the current least cost path from u to v.</li>
<li><strong>c(u, v)</strong> (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow></msub></mrow><annotation encoding="application/x-tex">c_{u, v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>) the cost from u to directly attached neighbor v</li>
<li><strong>N’</strong> subset of nodes along the current least-cost path from u-v.</li>
</ul>
</li>
</ul>
<h3 id="the-link-state-algorithm"><a class="markdownIt-Anchor" href="#the-link-state-algorithm"></a> The Link-state Algorithm</h3>
<ul>
<li>
<p>Base on <a target="_blank" rel="noopener" href="https://www.programiz.com/dsa/dijkstra-algorithm">Dijkstra’s Algorithm</a>.</p>
</li>
<li>
<p>Specs</p>
<ul>
<li><strong>centralized</strong>: network topology, link costs known to all nodes
<ul>
<li>accomplished via “link state broadcast”</li>
<li>all nodes have same info</li>
</ul>
</li>
<li>computes least cost paths from one node (“source”) to all other nodes
<ul>
<li>gives <strong>forwarding table</strong> for that node</li>
</ul>
</li>
<li>iterative: after k iterations, know least cost path to k destinations</li>
</ul>
</li>
<li>
<p>Algorithm</p>
<ul>
<li>
<img src="https://i.imgur.com/msB5AAM.jpg" style="width: 500px" />
</li>
<li>
<p>The key is <strong>in the loop, select the node with the least cost from the previous iteration</strong>.</p>
</li>
<li>
<p>Note that the edge is weighted, e.g.</p>
<ul>
<li>
<img src="https://i.imgur.com/jTYnBJ4.png" style="width: 500px" />
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Computational Complexity</p>
<ul>
<li>each iteration, loop <code>-1</code> elements. By the end, it’s <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mn>1</mn><mo>=</mo><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>≈</mo><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n + (n-1) + (n-2) + ... + 1 = n(n-1)/2 \approx n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></li>
<li>more efficient implementations possible: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span></span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>
<p>message complexity:</p>
<ul>
<li>each router must broadcast its link state information to other n routers</li>
<li>efficient (and interesting!) broadcast algorithms: <strong>O(n)</strong> link crossings to disseminate a broadcast message from one source</li>
<li>each router’s message crosses <strong>O(n)</strong> links: overall message complexity: <strong>O(n^2)</strong></li>
</ul>
</li>
</ul>
<h3 id="the-distance-vector-algorithm"><a class="markdownIt-Anchor" href="#the-distance-vector-algorithm"></a> The Distance-vector Algorithm</h3>
<ul>
<li>Base on <a target="_blank" rel="noopener" href="https://www.programiz.com/dsa/bellman-ford-algorithm">Bellman-Ford algorithm</a>. Each node maintains its own distance vector, with the costs to reach every other node in the network. Then, from time to time, each node sends its own distance vector to its neighbor nodes. The neighbor nodes in turn, receive that distance vector and they use it to update their own distance vectors.</li>
<li>How is the vector update is happening? Each node x updates its own distance vector using the Bellman Ford equation: <strong>Dx(y) = minv{c(x,v) + Dv(y)}</strong> for each destination node y in the network. A node x, computes the least cost to reach destination node y, by considering the options that it has to reach y through each of its neighbor v. So node x considers the cost to reach neighbor v, and then it adds the least cost from that neighbor v to the final destination y. It calculates that quantity over all neighbors v and it takes the minimum.</li>
<li>Psudocode:
<ul>
<li>
<img src="https://i.imgur.com/YcqJO6H.png" style="width: 500px" />
</li>
</ul>
</li>
<li>Now, let’s see an example of the distance vector routing algorithm. Let’s consider the three node network shown here:
<ul>
<li>
<img src="https://i.imgur.com/dljYM5y.png" style="width: 500px" />
</li>
</ul>
</li>
<li>In the first iteration, each node has its own view of the network, which is represented by an individual table. Every row in the table is the distance vector of each node. Node x has it’s own table, and the same is true for nodes y and z. We note that in the first iteration, node x does not have any information about y or z’s distance vectors, thus these values are set to infinity.</li>
<li>In the second iteration, the nodes exchange their distance vectors and they update their individual views of the network.</li>
<li>Node x computes its new distance vector, using the Bellman Ford equation for every destination node y and z. For each destination, node x compares the cost to reach that destination through a neighbor node.
<ul>
<li><code>dx(y) = min&#123;c(x,y) + dy(y), c(x,z)+dz(y) &#125; = min&#123;2+0, 7+1&#125; = 2</code></li>
<li><code>dx(z) = min&#123;c(x,y) + dy(z), c(x,z)+dz(z) &#125; = min&#123;2+1, 7+0&#125; = 3</code></li>
</ul>
</li>
<li>At the same time, node x receives the distance vectors from y and z from the first iteration. So it updates its table to reflect its view of the network accordingly.</li>
<li>Nodes y and z repeat the same steps to update their own tables.
<ul>
<li>
<img src="https://i.imgur.com/l9Hl51P.png" style="width: 500px" />
</li>
</ul>
</li>
<li>In the third iteration, the nodes process the distance vectors received from the previous iteration (if they have changed), and they repeat the same calculations. Finally, each node has its own routing table.
<ul>
<li>
<img src="https://i.imgur.com/K9lLEvf.png" style="width: 500px" />
</li>
</ul>
</li>
<li>Finally, at this point, there are no further updates sent from the nodes. Thus, the nodes are not doing any further calculations on their distance vectors. The nodes enter a waiting mode, until there is a change in the link costs.</li>
</ul>
<h4 id="the-count-to-infinity-problem"><a class="markdownIt-Anchor" href="#the-count-to-infinity-problem"></a> The count-to-infinity problem</h4>
<ul>
<li>
<img src="https://i.imgur.com/JrFpvsN.png" style="width: 500px" />
</li>
<li>
<p>Let’s assume that the cost of link y-x changed from 4 to 60.</p>
<ul>
<li>At t0 y detects that cost has changed, now it will update its distance vector thinking that it can still reach x through z with a total cost of 5+1=6</li>
<li>At t1, we have a routing loop, where z thinks it can reach x through y and y thinks it can reach x through z. This will be causing the packets to be bouncing back and forth between y and z until their tables change.</li>
<li>z and y keep updating each other about their new cost to reach x. For example, y computes its new cost to be 6, and then informs z. Then z computes its new cost to be 7, and then informs y, and so on.</li>
</ul>
</li>
<li>
<p>This back and forth continues for a total of 44 iterations, at which point z computes its cost to be larger than 50, and that point it will prefer to reach x directly rather than through y.</p>
</li>
<li>
<p>This link cost change took a long time to propagate among the nodes of the network. This is known as the <strong>count-to-infinity problem</strong>.</p>
</li>
</ul>
<h4 id="solution-to-the-count-to-infinity-problem-poison-reverse"><a class="markdownIt-Anchor" href="#solution-to-the-count-to-infinity-problem-poison-reverse"></a> Solution to the count-to-infinity problem: Poison reverse</h4>
<ul>
<li>since z reaches x through y, z will advertise to y that the distance to x is infinity (Dz(x)=infinity). However z knows that this is not true and Dz(x)=5. z tells this lie to y, as long as it knows that it can reach to x via y. Since y assumes that z has no path to x except via y, it will never send packets to x via z.</li>
<li>So z poisons the path from z to y.</li>
<li>Things change when the cost from x to y changes to 60. y will update its table and send packet to x directly with cost Dy(x)=60. It will inform z about its new cost to x, after this update is received. Then z will immediately shift its route to x to be via the direct (z,x) link at cost 50. Since there is a new path to x, z will inform y that Dz(x)=50.</li>
<li>When y receives this update from z, y will update Dy(x)=51=c(y,z)+Dz(x).</li>
<li>Since z is now on least cost path of y to reach x, y poisons the reverse path from z to x. Y tells z that Dy(x)=inf, even though y knows that Dy(x)=51.</li>
<li>This technique will solve the problem with 2 nodes, however poisoned reverse will not solve a general count to infinity problem involving 3 or more nodes that are not directly connected.</li>
</ul>
<h2 id="internet-approach-to-scalable-routing"><a class="markdownIt-Anchor" href="#internet-approach-to-scalable-routing"></a> Internet approach to scalable routing</h2>
<p>Aggregate routers into regions known as “<strong>autonomous systems</strong>” (AS) (a.k.a. “domains”)</p>
<ul>
<li>
<p><strong>intra-AS (aka “intra-domain”)</strong>: routing among within same AS (“network”)</p>
<ul>
<li>all routers in AS must run same intra-domain protocol</li>
<li>routers in different AS can run different intra-domain routing protocols</li>
<li>gateway router: at “edge” of its own AS, has link(s) to router(s) in other AS’es</li>
</ul>
</li>
<li>
<p><strong>inter-AS (aka “inter-domain”)</strong>: routing among AS’es</p>
<ul>
<li>gateways perform inter-domain routing (as well as intra-domain routing)</li>
</ul>
</li>
<li>
<p>Common Intra-AS Routing Protocols</p>
<ul>
<li>RIP: Routing Information Protocol [RFC 1723]
<ul>
<li>classic DV: DVs exchanged every 30 secs</li>
<li>no longer widely used</li>
</ul>
</li>
<li>OSPF: Open Shortest Path First  [RFC 2328]
<ul>
<li>link-state routing</li>
<li>IS-IS protocol (ISO standard, not RFC standard) essentially same as OSPF</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="routing-information-protocolrip"><a class="markdownIt-Anchor" href="#routing-information-protocolrip"></a> Routing Information Protocol(RIP)</h3>
<ul>
<li>
<p>The first version of RIP, released as a part of the BSD version of Unix, uses hop count as a metric (i.e. assumes link cost as 1). The metric for choosing a path could be shortest distance, lowest cost, or a load-balanced path. In RIP, routing updates are exchanged between neighbors periodically, using a RIP response message, as opposed to distance vectors in the DV Protocols. These messages, called <strong>RIP advertisements</strong>, contain information about sender’s distances to destination subnets.</p>
</li>
<li>
<p>Let’s look at a simple RIP example to illustrate how it works. The figure below shows a portion of the network. Here, A, B, C and D denote the routers and w, x, y and z denote the subnet masks.</p>
<ul>
<li>
<img src="https://i.imgur.com/qYLrL7Y.jpg" style="width: 500px" />
</li>
</ul>
</li>
<li>
<p>Each router maintains a routing table, which contains its own distance vector as well as the router’s forwarding table. If we have a look at the routing table of Router D, we will see that it has three columns: destination subnet, identification of the next router along the shortest path to the destination, and the number of hops to get to the destination along the shortest path. A routing table will have one row for each subnet in the <strong>AS</strong> (<strong>AS = Autonomous Systems</strong>, which will be discussed in more detail in Lesson 4).</p>
<ul>
<li>
<img src="https://i.imgur.com/36Oq2xl.jpg" style="width: 500px" />
</li>
</ul>
</li>
<li>
<p>For this example, the table in the above figure indicates that to send a datagram from router D to destination subnet w, the datagram should first be forwarded to neighboring router A; the table also indicates that destination subnet w is two hops away along the shortest path. Now if router D receives from router A the advertisement (the routing table information of router A) shown in the figure below it merges the advertisement with the old routing table.</p>
<ul>
<li>
<img src="https://i.imgur.com/8HWXozX.jpg" style="width: 500px" />
</li>
</ul>
</li>
<li>
<p>In particular, router D learns that there is now a path through router A to subnet z that is shorter than the path through router B. Therefore, router D updates its table to account for the new shortest path. The updated routing table is shown in the figure below. As the Distance Vector algorithm is in the process of converging or as new links or routers are getting added to the AS, the shortest path is changing.</p>
<ul>
<li>
<img src="https://i.imgur.com/837fX25.png" style="width: 500px" />
</li>
</ul>
</li>
<li>
<p>Each node maintains a RIP Table (Routing Table), which will have one row for each subnet in the AS. RIP version 2 allows subnet entries to be aggregated using route aggregation techniques.</p>
</li>
<li>
<p>If a router does not hear from its neighbor at least once every 180 seconds, that neighbor is considered to be no longer reachable (broken link). In this case, the local routing table is modified, and changes are propagated. Routers send request and response messages over UDP, using port number 520, which is layered on top of network-layer IP protocol. RIP is actually implemented as an application-level process.</p>
</li>
<li>
<p>Some of the challenges with RIP include updating routes, reducing convergence time, and avoiding loops/count-to-infinity problems.</p>
</li>
</ul>
<h3 id="open-shortest-path-first-ospf"><a class="markdownIt-Anchor" href="#open-shortest-path-first-ospf"></a> Open Shortest Path First (OSPF)</h3>
<p>It’s a routing protocol that uses a <strong>link-state routing algorithm</strong> to find the best path between the source and the destination router. OSPF was introduced as an advancement of the RIP Protocol, operating in upper-tier ISPs. It is a link-state protocol that uses flooding of link-state information and a Dijkstra least-cost path algorithm.</p>
<p>A link-state routing algorithm is a dynamic routing algorithm in which each router shares knowledge of its neighbors with every other router in the network. The network topology built as a result can be viewed as a directed graph with preset weights for each edge assigned by the administrator.</p>
<ul>
<li><strong>Hierarchy</strong>
<ul>
<li>Two-level hierarchy: local area, backbone.
<ul>
<li>link-state advertisements flooded only in area, or backbone</li>
<li>each node has detailed area topology; only knows direction to reach other destinations</li>
</ul>
</li>
<li>
<img src="https://i.imgur.com/MpgwIMY.jpg" style="width: 500px" />
</li>
<li>Each area runs its own OSPF link-state routing algorithm, with each router in an area broadcasting its link-state to all other routers in that area. Within each area, one or more <strong>area border routers</strong> are responsible for routing packets outside the area.</li>
<li>Exactly one OSPF area in the AS is configured to be the <strong>backbone area</strong>. The primary role of the backbone area is to route traffic between the other areas in the AS. The backbone always contains all area border routers in the AS and may contain non-border routers as well.</li>
<li>For packets routing between two different areas, it is required that the packet be sent through an <strong>area border router</strong>, <strong>through the backbone</strong>, and then to the area border router within the destination area before finally reaching the destination.</li>
</ul>
</li>
<li><strong>Operation</strong>
<ul>
<li>First, a graph (topological map) of the entire AS is constructed. Then, considering itself as the root node, each router computes the shortest-path tree to all subnets by running Djikstra’s algorithm locally. The link costs have been pre-configured by a network administrator. The administrator has a variety of choices while configuring the link costs. For instance, he may choose to set them to be inversely proportional to link capacity, or set them all to one. Given a set of link weights, OSPF provides the mechanisms for determining least-cost path routing.</li>
<li>Whenever there is a change in a link’s state, the router broadcasts routing information to all other routers in the AS, not just to its neighboring routers. It also periodically broadcasts a link’s state even if its state hasn’t changed.</li>
</ul>
</li>
<li><strong>Link State Advertisements</strong>
<ul>
<li>Every router within a domain that operates on OSPF uses <strong>Link State Advertisements (LSAs)</strong>. LSA communicates the router’s local routing topology to all other local routers in the same OSPF area. In practice, LSA is used for building a database (called the link state database) containing all the link states. LSAs are typically flooded to every router in the domain. This helps form a consistent network topology view. Any change in the topology requires corresponding changes in LSAs.</li>
</ul>
</li>
<li><strong>The refresh rate for LSAs</strong>
<ul>
<li>OSPF typically has a refresh rate for LSAs, which has a default period of 30 minutes. If a link comes alive before this refresh period is reached, the routers connected to that link ensure LSA flooding. Since the flooding process can happen multiple times, every router receives multiple copies of refreshes or changes - and stores the first received LSA change as new and the subsequent ones as duplicates.</li>
</ul>
</li>
</ul>
<h4 id="processing-ospf-messages-in-the-router"><a class="markdownIt-Anchor" href="#processing-ospf-messages-in-the-router"></a> Processing OSPF Messages in the Router</h4>
<img src="https://i.imgur.com/qjpQLy4.jpg" style="width: 500px" />
<ul>
<li>Let’s begin with a simple model of a router given in the figure above. The router consists of a route processor (which is the main processing unit) and interface cards that receive data packets which are forwarded via a switching fabric. Let us break down router processing in a few steps:</li>
<li>Initially, the LS update packets which contain LSAs from a neighboring router reaches the current router’s OSPF (which is the route processor). This is the first trigger for the route processor. As the LS Updates reach the router, a consistent view of the topology is being formed and this information is stored in the link-state database. Entries of LSAs correspond to the topology which is actually visible from the current router.</li>
<li>Using this information from the link-state database, the current router calculates the shortest path using shortest path first (SPF) algorithm. The result of this step is fed to the Forwarding Information Base (FIB)</li>
<li>The information in the FIB is used when a data packet arrives at an interface card of the router, where the next hop for the packet is decided and its forwarded to the outgoing interface card.</li>
</ul>
<p>To further understand OSPF processing, let’s look at the following flow chart and view it in time slices (T1, T2, …, T7).</p>
<img src="https://i.imgur.com/NCy0UrE.png" style="width: 500px" />
<img src="https://i.imgur.com/FEcOnST.png" style="width: 500px" />
<h2 id="hot-potato-routing"><a class="markdownIt-Anchor" href="#hot-potato-routing"></a> Hot Potato Routing</h2>
<ul>
<li>In large networks, routers rely both on interdomain and intradomain routing protocols to route the traffic.</li>
<li>The routers within the network use the intradomain routing protocols to find the best path to route the traffic within the network. In case when the final destination of the traffic is outside the network, then the traffic will travel towards the networks exit (egress points) before leaving the network. In some cases there are multiple egress points that the routers can choose from. These egress points (routers) can be equally good in the sense that they offer similarly good external paths to the final destination.</li>
<li>In this case, hot potato routing is a technique/practice of choosing a path within the network, by choosing the closest egress point based on intradomain path cost (Interior Gateway Protocol/IGP cost).</li>
</ul>
<h2 id="an-example-traffic-engineering-frameworkoptional"><a class="markdownIt-Anchor" href="#an-example-traffic-engineering-frameworkoptional"></a> An Example Traffic Engineering Framework[Optional]</h2>
<ul>
<li>
<p>It involves three main components: <strong>measure</strong>, <strong>model</strong> and <strong>control</strong> as shown in the below figure:</p>
<ul>
<li>
<img src="https://i.imgur.com/lSY8uGJ.jpg" style="width: 500px" />
</li>
</ul>
</li>
<li>
<p><strong>Measure</strong>: The efficient assignment of link weights depends on the real time view of the network state which includes:</p>
<ul>
<li>the operational routers and links,</li>
<li>the link capacity and IGP parameters configuration.</li>
</ul>
</li>
<li>
<p>The status of the network elements can be obtained using <strong>Simple Network Management Protocol (SNMP)</strong> <strong>polling</strong> or via SNMP <strong>traps</strong>. The link capacity and the IGP parameters can be gathered from the configuration data of the routers or external databases that enable the provisioning of the network elements. Furthermore, a software router could act as <strong>an IGP route monitor</strong> by participating in OSPF/IS-IS with operational routers and reporting real time topology information.</p>
</li>
<li>
<p>In addition to the current network state, the network operator also requires an estimate of the traffic in the network that can be acquired either by prior history or by using the following measurement techniques:</p>
<ol>
<li>Directly from the SNMP Management Information Bases (MIBs)</li>
<li>By combining packet-level measurements at the network edge using the information in routing tables</li>
<li>Network tomography which involves observing the aggregate load on the links along with the routing data</li>
<li>Direct observation of the traffic using new packet sampling techniques</li>
</ol>
</li>
<li>
<p><strong>Model</strong>: This involves predicting the traffic flow through the network based on the IGP configuration. The best path between two routers is selected by calculating the shortest path between them when all the links belong to the same OSPF/IS-IS area. In case of large networks consisting of multiple OSPF/IS-IS areas, the path selection among routers in different areas is dependent on the summary information passed across the area boundaries. If there are multiple shortest paths between two routers, it is leveraged for load balancing by splitting the traffic almost evenly over these paths.</p>
</li>
<li>
<p>The routing model thus aims to compute a set of paths between each pair of routers, with each path representing the fraction of traffic that passes through each link. The volume of traffic on a link can now be estimated by combining the output of the routing model and the estimated traffic demands.</p>
</li>
<li>
<p><strong>Control</strong>: The new link weights are applied on the affected routers by connecting to the router using telnet or ssh. The exact commands are dependent on the operating systems of the router. These updates may be automated or done manually depending on the size of the network.</p>
</li>
<li>
<p>Once a router receives a weight change, it updates its link-state database and floods the newly updated value to the entire network. On receiving the updated value, each router in turn updates its link-state database, recomputes the shortest paths and updates affected entries in its forwarding table.  Similar to when there is a topology change or a failure, this involves a transition period where there is a slightly inconsistent view of the shortest path for few destinations. Although the convergence after a weight change is faster than a failure scenario (as there is no delay in detecting a failure), it still involves a transient period in the network. Hence, understandably, changing the link weights is not done frequently and only done in scenarios where there is new hardware, equipment failures or changes in traffic demands.</p>
</li>
</ul>

</div>


  <div class="book-comments">
    




  </div>



<script src="/js/book-post.js"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">
  
  <div class="divider"></div>
</div>

  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/js/book-toc.js"></script>

</div>

      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/js/book.js"></script>

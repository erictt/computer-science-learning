<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          Eric&#39;s CS Notes
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 6.0.0"></head>


<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>ERIC&#39;S CS NOTES</span>
  </a>
</div>

    <div class="book-menu">
  
</div>


<script src="/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <h1 id="lecture-3"><a class="markdownIt-Anchor" href="#lecture-3"></a> Lecture 3</h1>
<h2 id="computational-models"><a class="markdownIt-Anchor" href="#computational-models"></a> Computational Models</h2>
<ul>
<li>Programs that help us understand the world and solve practical problems</li>
</ul>
<h3 id="graph"><a class="markdownIt-Anchor" href="#graph"></a> Graph</h3>
<h4 id="definition"><a class="markdownIt-Anchor" href="#definition"></a> Definition</h4>
<ul>
<li>Set of nodes (vertices) with properties</li>
<li>Set of edges (arcs) each consisting of a pair of nodes
<ul>
<li>Undirected (graph)</li>
<li>Directed (digraph)
<ul>
<li>Source (parent) and destination (child) nodes</li>
</ul>
</li>
<li>Unweighted or weighted</li>
</ul>
</li>
</ul>
<h4 id="usage"><a class="markdownIt-Anchor" href="#usage"></a> Usage</h4>
<ul>
<li>To capture useful relationships among entities
<ul>
<li>Rail links between Paris and London</li>
<li>How the atoms in a molecule related to one another</li>
<li>Ancestral relationships</li>
</ul>
</li>
</ul>
<h4 id="samples"><a class="markdownIt-Anchor" href="#samples"></a> Samples</h4>
<ul>
<li>Leonhard Euler’s Model (First Reported Use of Graph Theory)
<ul>
<li>
<img src="https://i.imgur.com/nE4hbIS.png" style="width:400px"/>
</li>
<li>Each island a node</li>
<li>Each bridge an undirected edge</li>
<li><strong>Model abstracts away irrelevant details</strong>
<ul>
<li>Size of islands</li>
<li>Length of bridges</li>
</ul>
</li>
<li>Is there a path that contains each edge exactly once?</li>
</ul>
</li>
</ul>
<h2 id="graph-theoretic-models"><a class="markdownIt-Anchor" href="#graph-theoretic-models"></a> Graph-theoretic Models</h2>
<h3 id="common-representations-of-digraphs"><a class="markdownIt-Anchor" href="#common-representations-of-digraphs"></a> Common Representations of Digraphs</h3>
<ul>
<li>Adjacency matrix
<ul>
<li>Rows: source nodes</li>
<li>Columns: destination nodes</li>
<li>Cell[s, d] = 1 if there is an edge from s to d
<ul>
<li>0 otherwise</li>
</ul>
</li>
</ul>
</li>
<li><strong>Adjacency list</strong> (We are trying this one first)
<ul>
<li>Associate with each node a list of destination nodes</li>
</ul>
</li>
</ul>
<h4 id="sample"><a class="markdownIt-Anchor" href="#sample"></a> Sample</h4>
<ul>
<li>
<p>Finding a route from one city to another</p>
<ul>
<li>
<img src="https://i.imgur.com/sadQXWL.png" style="width:400px"/>
</li>
</ul>
</li>
<li>
<p>Four classes:</p>
<ul>
<li>
<p>Node</p>
<ul>
<li>property: <code>name</code></li>
</ul>
</li>
<li>
<p>Edge</p>
<ul>
<li>properties: <code>source</code> and <code>dest</code> which are substances of class <code>Node</code></li>
</ul>
</li>
<li>
<p>Digraph</p>
<ul>
<li>properties: <code>edges</code> is a <code>K-V</code> sets data, <code>K</code> for source node, and <code>V</code> for destination node.</li>
<li>method <code>addNode</code> to add Node object as the <code>K</code> of <code>edges</code>.</li>
<li>method <code>addEdge</code> to add Edge object, which will append the <code>dest</code> property of Edge object to <code>edges</code> with the specific <code>K</code>.</li>
<li>method <code>chirdrenOf</code> to return all the child nodes</li>
<li>method <code>hasNode</code> in <code>self.edges</code></li>
<li>method <code>getNode</code> by node’s name</li>
</ul>
</li>
<li>
<p>Graph - is a subclass of Digraph</p>
<ul>
<li><code>addEdge</code>: rewrite the <code>addEdge</code> method to add another set with reversed source and destination nodes.</li>
</ul>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://github.com/erictt/computer-science-learning/tree/master/computational-thinking/unit-1/lecture3-segment2.py">Codes</a></p>
</li>
</ul>
</li>
</ul>
<h3 id="algorithm-depth-first-searchdfs"><a class="markdownIt-Anchor" href="#algorithm-depth-first-searchdfs"></a> Algorithm: Depth First Search[DFS]</h3>
<ul>
<li>
<p>Similar to left-first depth-first method of enumerating a search tree, mainly difference is that graph might have cycles, so we must keep track of what nodes we have visited</p>
</li>
<li>
<p>Implement <a target="_blank" rel="noopener" href="https://github.com/erictt/computer-science-learning/tree/master/computational-thinking/unit-1/lecture3-segment3.py">Codes</a></p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">graph, start, end, path, shortest, toPrint</span>):</span><br><span class="line">    path = path + [start]     </span><br><span class="line">    <span class="keyword">if</span> start == end:</span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> graph.childrenOf(start):</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> path: <span class="comment">#avoid cycles</span></span><br><span class="line">            <span class="keyword">if</span> shortest == <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(path) &lt; <span class="built_in">len</span>(shortest):</span><br><span class="line">                <span class="string">&quot;&quot;&quot;Will have values until node == end,</span></span><br><span class="line"><span class="string">                     then save as shortest</span></span><br><span class="line"><span class="string">                   And compare it with current path </span></span><br><span class="line"><span class="string">                     if path is still shorter</span></span><br><span class="line"><span class="string">                     (don&#x27;t need to continue if it isn&#x27;t shorter), </span></span><br><span class="line"><span class="string">                   unless this shortest one will be returned</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span></span><br><span class="line">                newPath = DFS(graph, node, end, path, shortest, toPrint)</span><br><span class="line">                <span class="keyword">if</span> newPath != <span class="literal">None</span>:</span><br><span class="line">                    shortest = newPath</span><br><span class="line">    <span class="keyword">return</span> shortest</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shortestPath</span>(<span class="params">graph, start, end</span>):</span><br><span class="line">    <span class="keyword">return</span> DFS(graph, start, end, [], <span class="literal">None</span>, toPrint)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="algorithm-breadth-first-searchbfs"><a class="markdownIt-Anchor" href="#algorithm-breadth-first-searchbfs"></a> Algorithm: Breadth First Search[BFS]</h3>
<ul>
<li>
<p>Explore the nodes layer by layer, like first we got a node as start node, then check all the children nodes, then children’s children, it will keep going until we got the node equal the end node. And that’s the path we are looking for, just return it.</p>
</li>
<li>
<p>Implement <a target="_blank" rel="noopener" href="https://github.com/erictt/computer-science-learning/tree/master/computational-thinking/unit-1/lecture3-segment3.py">Codes</a></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; Explore all paths with n hops </span></span><br><span class="line"><span class="string">    before exploring any path with more than n hops&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">BFS</span>(<span class="params">graph, start, end, toPrint = <span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Assumes graph is a Digraph; start and end are nodes</span></span><br><span class="line"><span class="string">       Returns a shortest path from start to end in graph&quot;&quot;&quot;</span></span><br><span class="line">    initPath = [start]</span><br><span class="line">    pathQueue = [initPath]</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(pathQueue) != <span class="number">0</span>:</span><br><span class="line">        <span class="comment">#Get and remove oldest element in pathQueue</span></span><br><span class="line">        tmpPath = pathQueue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> toPrint:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Current BFS path:&#x27;</span>, printPath(tmpPath))</span><br><span class="line">        lastNode = tmpPath[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> lastNode == end:</span><br><span class="line">            <span class="keyword">return</span> tmpPath</span><br><span class="line">        <span class="keyword">for</span> nextNode <span class="keyword">in</span> graph.childrenOf(lastNode):</span><br><span class="line">            <span class="keyword">if</span> nextNode <span class="keyword">not</span> <span class="keyword">in</span> tmpPath:</span><br><span class="line">                newPath = tmpPath + [nextNode]</span><br><span class="line">                pathQueue.append(newPath)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="summary"><a class="markdownIt-Anchor" href="#summary"></a> Summary</h2>
<ul>
<li>Graph is used to create a model of many things
<ul>
<li>Capture relationships among objects</li>
</ul>
</li>
<li>DFS and BFS can be used for searching shortest path</li>
</ul>
<h2 id="words"><a class="markdownIt-Anchor" href="#words"></a> Words</h2>
<p><strong>digraph</strong>  ['daiɡrɑ:f, -ɡræf] n. 有向图</p>

</div>


  <div class="book-comments">
    




  </div>



<script src="/js/book-post.js"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">
  
  <div class="divider"></div>
</div>

  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/js/book-toc.js"></script>

</div>

      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/js/book.js"></script>

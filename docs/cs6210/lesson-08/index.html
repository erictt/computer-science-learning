<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          Eric&#39;s CS Notes
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.18.2/tocbot.css">
    
    <!-- katex css -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.css" integrity="sha384-Juol1FqnotbkyZUT5Z7gUPjQ9gzlwCENvUZTpQBAPxtusdwFLRy382PSDx5UUJ4/" crossorigin="anonymous">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 6.3.0"></head>


<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>ERIC&#39;S CS NOTES</span>
  </a>
</div>

    <div class="book-menu">
  <!--
## Introduction to Probability

* [Unit 1: Probability models and axioms](/introduction-to-probability/unit-1/index.html)
* [Unit 2: Conditioning and independence](/introduction-to-probability/unit-2/index.html)
* [Unit 3: Counting](/introduction-to-probability/unit-3/index.html)
* [Unit 4: Discrete random variables](/introduction-to-probability/unit-4/index.html)
* [Unit 5: Continuous random variables](/introduction-to-probability/unit-5/index.html)
* [Unit 6: Further topics on random variables](/introduction-to-probability/unit-6/index.html)
* [Unit 7: Bayesian inference](/introduction-to-probability/unit-7/index.html)
* [Unit 8: Limit theorems and classical statistics](/introduction-to-probability/unit-8/index.html)
* [Unit 9: Bernoulli and Poisson processes](/introduction-to-probability/unit-9/index.html)
* [Unit 10: Markov chains](/introduction-to-probability/unit-10/index.html)
-->
<!--
## Multivariable Calculus

* [Unit 1: Thinking about multivariable functions](/multivariable-calculus/unit-1/index.html)
* [Unit 2: Derivatives of multivariable functions](/multivariable-calculus/unit-2/index.html)

* [Unit 3: Applications of multivariable derivatives](/multivariable-calculus/unit-3/index.html)
* [Unit 4: Integrating multivariable functions](/multivariable-calculus/unit-4/index.html)
* [Unit 5: Green's, Stokes', and the divergence theorems](/multivariable-calculus/unit-5/index.html)
-->
<h2 id="cs6210-advanced-operating-systems"><a class="markdownIt-Anchor" href="#cs6210-advanced-operating-systems"></a> CS6210: Advanced Operating Systems</h2>
<ul>
<li><a href="/cs6210/lesson-02/index.html">Lesson 2: OS Structure</a></li>
<li><a href="/cs6210/lesson-03/index.html">Lesson 3: Virtualization</a></li>
<li><a href="/cs6210/lesson-04a/index.html">Lesson 4: Parallel Systems - Part 1</a></li>
<li><a href="/cs6210/lesson-04b/index.html">Lesson 4: Parallel Systems - Part 2</a></li>
<li><a href="/cs6210/lesson-05/index.html">Lesson 5: Distributed Systems</a></li>
<li><a href="/cs6210/lesson-06/index.html">Lesson 6: Distributed Objects and Middleware</a></li>
<li><a href="/cs6210/lesson-07a/index.html">Lesson 7: Distributed Subsystems - GMS</a></li>
<li><a href="/cs6210/lesson-07b/index.html">Lesson 7: Distributed Subsystems - DSM</a></li>
<li><a href="/cs6210/lesson-07c/index.html">Lesson 7: Distributed Subsystems - DFS</a></li>
<li><a href="/cs6210/lesson-09/index.html">Lesson 9: Internet Computing</a></li>
<li><a href="/cs6210/lesson-10/index.html">Lesson 10: RT and Multimedia</a></li>
<li><a href="/cs6210/lesson-08/index.html">Lesson 8: Failures and Recovery</a></li>
<li><a href="/cs6210/lesson-11/index.html">Lesson 11: Security</a></li>
</ul>
<h2 id="cs6250-computer-networks"><a class="markdownIt-Anchor" href="#cs6250-computer-networks"></a> CS6250 Computer Networks</h2>
<ul>
<li><a href="/cs6250/week-1-internet-architecture/index.html">Week 1 - Internet Architecture</a></li>
<li><a href="/cs6250/week-2-transport-and-application-layers/index.html">Week 2 - Transport and Application Layers</a></li>
<li><a href="/cs6250/week-3-intradomain-routing/index.html">Week 3 - Intradomain Routing</a></li>
<li><a href="/cs6250/week-4-as-relationships-and-interdomain-routing/index.html">Week 4 - AS Relationships and Interdomain Routing</a></li>
<li><a href="/cs6250/week-5-router-design-and-algorithems-part-1/index.html">Week 5 - Router Design and Algorithms (Part 1)</a></li>
<li><a href="/cs6250/week-6-router-design-and-algorithems-part-2/index.html">Week 6 - Router Design and Algorithms (Part 2)</a></li>
<li><a href="/cs6250/week-7-software-defined-networking-part-1/index.html">Week 7 - Software Defined Networking (Part 1)</a></li>
<li><a href="/cs6250/week-8-software-defined-networking-part-2/index.html">Week 8 - Software Defined Networking (Part 2)</a></li>
<li><a href="/cs6250/week-9-internet-security/index.html">Week 9 - Internet Security</a></li>
<li><a href="/cs6250/week-10-internet-surveillance-and-censorship/index.html">Week 10 - Internet Surveillance and Censorship</a></li>
<li><a href="/cs6250/week-11-applications-video/index.html">Week 11 - Applications Videos</a></li>
<li><a href="/cs6250/week-12-applications-cdns-and-overlay-networks/index.html">Week 12 - Applications CDNs and Overlay Networks</a></li>
</ul>
<h2 id="cs6200-graduate-introduction-to-operating-systems"><a class="markdownIt-Anchor" href="#cs6200-graduate-introduction-to-operating-systems"></a> CS6200 Graduate Introduction to Operating Systems</h2>
<ul>
<li><a href="/cs6200/p1-preparation/index.html">P0 - Preparation</a></li>
<li><a href="/cs6200/p1l2-introduction/index.html">P1L2 - Introduction</a></li>
<li><a href="/cs6200/p2l1-processes-and-process-management/index.html">P2L1 - Processes and Process Management</a></li>
<li><a href="/cs6200/p2l2-threads-and-concurrency/index.html">P2L2 - Threads and Concurrency</a></li>
<li><a href="/cs6200/p2l3-pthread/index.html">P2L3 - PThread</a></li>
<li><a href="/cs6200/p2l4-thread-design-consideration/index.html">P2L4 - Thread Design Considerations</a></li>
<li><a href="/cs6200/p2l5-thread-performance-consideration/index.html">P2L5 - Thread Performance Considerations</a></li>
<li><a href="/cs6200/p3l1-scheduling/index.html">P3L1 - Scheduling</a></li>
<li><a href="/cs6200/p3l2-memory-management/index.html">P3L2 - Memory Management</a></li>
<li><a href="/cs6200/p3l3-inter-process-communication/index.html">P3L3 - Inter-Process Communication</a></li>
<li><a href="/cs6200/p3l4-synchronization-constructs/index.html">P3L4 - Synchronization Constructs</a></li>
<li><a href="/cs6200/p3l5-io-management/index.html">P3L5 - I/O Management</a></li>
<li><a href="/cs6200/p3l6-virtualization/index.html">P3L6 - Virtualization</a></li>
</ul>
<!--
* [P4L1 - Remote Procedure Calls](/cs6200/p4l1-remote-procedure-calls/index.html) 
* [P4L2 - Distributed File Systems](/cs6200/p4l2-distributed-file-systems/index.html) 
* [P4L3 - Distributed Shared Memory](/cs6200/p4l3-distributed-shared-memory/index.html) 
* [P4L4 - Datacenter Technologies](/cs6200/p4l4-datacenter-technologies/index.html) 
-->
<h2 id="algorithms-part-ii"><a class="markdownIt-Anchor" href="#algorithms-part-ii"></a> Algorithms: Part II</h2>
<ul>
<li><a href="/algorithms-2/week-1/index.html">Week 1 - Undirected Graph &amp; Directed Graph</a></li>
<li><a href="/algorithms-2/week-2/index.html">Week 2 - Minimum Spanning Trees &amp; Shortest Path</a></li>
<li><a href="/algorithms-2/week-3/index.html">Week 3 - Maximum Flow and Minimum Cut &amp; String Sort</a></li>
<li><a href="/algorithms-2/week-4/index.html">Week 4 - Tries &amp; Substring Search</a></li>
<li><a href="/algorithms-2/week-5/index.html">Week 5 - Regular Expressions</a></li>
<li><a href="/algorithms-2/week-6/index.html">Week 6 - Reductions</a></li>
</ul>
<h2 id="algorithms-part-i"><a class="markdownIt-Anchor" href="#algorithms-part-i"></a> Algorithms: Part I</h2>
<ul>
<li><a href="/algorithms-1/week-1/index.html">Week 1 - Union-Find &amp; Analysis of Algorithms</a></li>
<li><a href="/algorithms-1/week-2/index.html">Week 2 - Stacks and Queues &amp; Elementary Sorts</a></li>
<li><a href="/algorithms-1/week-3/index.html">Week 3 - Mergesort &amp; Quicksort</a></li>
<li><a href="/algorithms-1/week-4/index.html">Week 4 - Priority Queues &amp; Elementary Symbols</a></li>
<li><a href="/algorithms-1/week-5/index.html">Week 5 - Balanced Search Trees</a></li>
<li><a href="/algorithms-1/week-6/index.html">Week 6 - Hash Tables</a></li>
</ul>
<h2 id="introduction-to-software-design-and-architecture"><a class="markdownIt-Anchor" href="#introduction-to-software-design-and-architecture"></a> Introduction to Software Design and Architecture</h2>
<ul>
<li><a href="/introduction-to-software-design-and-architecture/design-pattern/index.html">Design Pattern</a></li>
</ul>
<h2 id="calculus-two-sequences-and-series"><a class="markdownIt-Anchor" href="#calculus-two-sequences-and-series"></a> Calculus Two: Sequences and Series</h2>
<ul>
<li><a href="/calculus-two/week-1/index.html">Week 1 - Sequences</a></li>
<li><a href="/calculus-two/week-2/index.html">Week 2 - Series</a></li>
<li><a href="/calculus-two/week-3/index.html">Week 3 - Convergence Tests</a></li>
<li><a href="/calculus-two/week-4/index.html">Week 4 - Alternating Series</a></li>
<li><a href="/calculus-two/week-5/index.html">Week 5 - Power Series</a></li>
<li><a href="/calculus-two/week-6/index.html">Week 6 - Taylor Series</a></li>
</ul>
<h2 id="laff-linear-algebra"><a class="markdownIt-Anchor" href="#laff-linear-algebra"></a> LAFF Linear Algebra</h2>
<ul>
<li><a href="/laff-linear-algebra/week-1/index.html">Week 1 - Vectors in Linear Algebra</a></li>
<li><a href="/laff-linear-algebra/week-2/index.html">Week 2 - Linear Transformations and Matrices</a></li>
<li><a href="/laff-linear-algebra/week-3/index.html">Week 3 - Matrix-Vector Operations</a></li>
<li><a href="/laff-linear-algebra/week-4/index.html">Week 4 - Matrix-Vector to Matrix-Matrix Multiplication</a></li>
<li><a href="/laff-linear-algebra/week-5/index.html">Week 5 - Matrix- Matrix Multiplication</a></li>
<li><a href="/laff-linear-algebra/week-6/index.html">Week 6 - Gaussian Elimination</a></li>
<li><a href="/laff-linear-algebra/week-7/index.html">Week 7 - More Gaussian Elimination and Matrix Inversion</a></li>
<li><a href="/laff-linear-algebra/week-8/index.html">Week 8 - More on Matrix Inversion</a></li>
<li><a href="/laff-linear-algebra/week-9/index.html">Week 9 - Vector Spaces</a></li>
<li><a href="/laff-linear-algebra/week-10/index.html">Week 10 - Vector Spaces, Orthogonality, and Linear Least-Squares</a></li>
<li><a href="/laff-linear-algebra/week-11/index.html">Week 11 - Orthogonal Projection, Low Rank Approximation, and Orthogonal Bases</a></li>
<li><a href="/laff-linear-algebra/week-12/index.html">Week 12 - Eigenvalues and Eigenvectors</a></li>
</ul>
<h2 id="stanford-machine-learning"><a class="markdownIt-Anchor" href="#stanford-machine-learning"></a> Stanford Machine Learning</h2>
<ul>
<li><a href="/stanford-machine-learning/week-1/index.html">Week 1 - Introduction</a></li>
<li><a href="/stanford-machine-learning/week-2/index.html">Week 2 - Linear Regression with Multiple Variables</a></li>
<li><a href="/stanford-machine-learning/week-3/index.html">Week 3 - Logistic Regression &amp; Regularization</a></li>
<li><a href="/stanford-machine-learning/week-4/index.html">Week 4 - Neural Networks: Representation</a></li>
<li><a href="/stanford-machine-learning/week-5/index.html">Week 5 - Neural Networks: Learning</a></li>
<li><a href="/stanford-machine-learning/week-6a/index.html">Week 6a - Advice for Applying Machine Learning</a></li>
<li><a href="/stanford-machine-learning/week-6b/index.html">Week 6b - Machine Learning System Design</a></li>
<li><a href="/stanford-machine-learning/week-7/index.html">Week 7 - Support Vector Machines</a></li>
<li><a href="/stanford-machine-learning/week-8/index.html">Week 8 - Unsupervised Learning &amp; Dimensionality Reduction</a></li>
<li><a href="/stanford-machine-learning/week-9a/index.html">Week 9a - Anomaly Detection</a></li>
<li><a href="/stanford-machine-learning/week-9b/index.html">Week 9b - Recommender Systems</a></li>
<li><a href="/stanford-machine-learning/week-10/index.html">Week 10 - Large Scale Machine Learning</a></li>
<li><a href="/stanford-machine-learning/week-11/index.html">Week 11 - Application Example: Photo OCR</a></li>
</ul>
<h2 id="calculus-one"><a class="markdownIt-Anchor" href="#calculus-one"></a> Calculus One</h2>
<ul>
<li><a href="/calculus-one/week-2-3/index.html">Week 2-3 - Functions &amp; Limits</a></li>
<li><a href="/calculus-one/week-4/index.html">Week 4 - The Beginning of Derivatives</a></li>
<li><a href="/calculus-one/week-5/index.html">Week 5 - Techniques of Differentiation</a></li>
<li><a href="/calculus-one/week-6/index.html">Week 6 - Chain Rule</a></li>
<li><a href="/calculus-one/week-7/index.html">Week 7 - Derivatives of Trigonometric Functions</a></li>
<li><a href="/calculus-one/week-8/index.html">Week 8 - Derivatives in the Real World</a></li>
<li><a href="/calculus-one/week-9/index.html">Week 9 - Optimization</a></li>
<li><a href="/calculus-one/week-10/index.html">Week 10 - Linear Approximation</a></li>
<li><a href="/calculus-one/week-11-12/index.html">Week 11-12 - Antidifferentiation &amp; Integration</a></li>
<li><a href="/calculus-one/week-13/index.html">Week 13 - Fundamental Theorem of Calculus</a></li>
<li><a href="/calculus-one/week-14/index.html">Week 14 - Substitution Rule</a></li>
<li><a href="/calculus-one/week-15/index.html">Week 15 - Techniques of Integration</a></li>
<li><a href="/calculus-one/week-16/index.html">Week 16 - Applications of Integration</a></li>
</ul>
<h2 id="computational-thinking"><a class="markdownIt-Anchor" href="#computational-thinking"></a> Computational Thinking</h2>
<ul>
<li><a href="/computational-thinking/lecture-1/index.html">Lecture 1 - Optimization and Knapsack Problem</a></li>
<li><a href="/computational-thinking/lecture-2/index.html">Lecture 2 - Decision Trees and Dynamic Programming</a>
<ul>
<li><a href="/computational-thinking/lecture-2-powerset/index.html">Exercise: Power Set Function</a></li>
</ul>
</li>
<li><a href="/computational-thinking/lecture-3/index.html">Lecture 3 - Graphs</a></li>
<li><a href="/computational-thinking/lecture-4-5/index.html">Lecture 4-5 - Plotting</a></li>
<li><a href="/computational-thinking/lecture-6-7/index.html">Lecture 6-7 - Stochastic Programs &amp; Inferential Statistics</a></li>
<li><a href="/computational-thinking/lecture-8/index.html">Lecture 8 - Monte Carlo Simulation</a></li>
<li><a href="/computational-thinking/lecture-9/index.html">Lecture 9 - Sampling and Standard Error</a></li>
<li><a href="/computational-thinking/lecture-10-11/index.html">Lecture 10-11 - Experimental Data</a></li>
<li><a href="/computational-thinking/lecture-12/index.html">Lecture 12 - Machine Learning</a></li>
<li><a href="/computational-thinking/lecture-13/index.html">Lecture 13 - Statistical Abuses</a></li>
</ul>
<h2 id="effective-thinking-through-mathematics"><a class="markdownIt-Anchor" href="#effective-thinking-through-mathematics"></a> Effective Thinking Through Mathematics</h2>
<ul>
<li><a href="/effective-thinking-through-mathematics/note/index.html">Note</a></li>
<li><a href="/effective-thinking-through-mathematics/week-4-telling-the-story-of-infinity/index.html">Week 4 (/Telling the Story of Infinity)</a></li>
<li><a href="/effective-thinking-through-mathematics/week-5-telling-the-story-of-the-euler-circuit-theorem/index.html">Week 5 (/Telling the Story of Euler Circuit Theorem)</a></li>
</ul>
<h2 id="cs50-introduction-to-computer-science"><a class="markdownIt-Anchor" href="#cs50-introduction-to-computer-science"></a> CS50 Introduction to Computer Science</h2>
<ul>
<li><a href="/cs50/week-1/index.html">Week 1 - C</a></li>
<li><a href="/cs50/week-2/index.html">Week 2 - Arrays</a></li>
<li><a href="/cs50/week-3/index.html">Week 3 - Algorithms</a></li>
<li><a href="/cs50/week-4/index.html">Week 4 - Memory</a></li>
<li><a href="/cs50/week-5/index.html">Week 5 - Data Structures</a></li>
<li><a href="/cs50/week-6/index.html">Week 6 - HTTP</a></li>
<li><a href="/cs50/week-7-10/index.html">Week 7-10 - Machine Learning/Python/SQL/Javascript</a></li>
</ul>
<h2 id="others"><a class="markdownIt-Anchor" href="#others"></a> Others</h2>
<ul>
<li><a href="/symbols/index.html">Symbols of Mathematics</a></li>
<li><a href="/glossary/index.html">Glossary</a></li>
</ul>
<h2 id="about-me"><a class="markdownIt-Anchor" href="#about-me"></a> <a target="_blank" rel="noopener" href="https://ericy.me/about/">About Me</a></h2>

</div>


<script src="/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <h1 id="lesson-08-failures-and-recovery"><a class="markdownIt-Anchor" href="#lesson-08-failures-and-recovery"></a> Lesson 08: Failures and Recovery</h1>
<p>The goal of this module is to build a system that help the subsystems to survive crashes. To do that, we need to provide persistence support for the subsystems and also make it performant.</p>
<h2 id="l08a-lightweight-recoverable-virtual-memorylrvm"><a class="markdownIt-Anchor" href="#l08a-lightweight-recoverable-virtual-memorylrvm"></a> L08a: Lightweight Recoverable Virtual Memory(LRVM)</h2>
<p>LRVM is a lightweight runtime library that offer interfaces that allow application to persist the virtual memory to the disk.</p>
<h3 id="server-design"><a class="markdownIt-Anchor" href="#server-design"></a> Server Design</h3>
<p><img src="https://i.imgur.com/0mQV6PV.png" alt=""><br>
The LRVM create external data segments to back persistent data structures for the applications<br>
The application can create as many as data segments it wants.</p>
<h3 id="rvm-primitives"><a class="markdownIt-Anchor" href="#rvm-primitives"></a> RVM Primitives</h3>
<p>Initialization:</p>
<ul>
<li><code>initialize(options)</code>
<ul>
<li>Declares a log segment for aggregating changes made to persistent data structures.</li>
</ul>
</li>
<li><code>map(region, options)</code>
<ul>
<li>Maps a region of virtual address space to an external data segment.</li>
</ul>
</li>
<li><code>unmap(region)</code>
<ul>
<li>Decouples a region of virtual address space from its associated external data segment.</li>
</ul>
</li>
</ul>
<p>Body of server code:</p>
<ul>
<li><code>begin_transaction(tid, restore_mode)</code>
<ul>
<li>Signals the RVM runtime that changes will be made to persistent data structures between begin_transaction and end_transaction calls. The restore_mode specifies how to restore the state of the data structures in case of failure.</li>
</ul>
</li>
<li><code>set_range(tid, addr, size)</code>
<ul>
<li>Being called at the beginning of the transaction.</li>
<li>Specifies a block of memory to modify within the critical section between begin_transaction and end_transaction calls.</li>
</ul>
</li>
<li><code>end_transaction(tid, commit_mode)</code>
<ul>
<li>Signals the RVM runtime to commit changes made to persistent data structures in the current transaction. The commit_mode specifies how to handle flushing of the redo log to disk.</li>
</ul>
</li>
<li><code>abort_transcation(tid)</code>
<ul>
<li>Signals the RVM runtime to throw away changes made to persistent data structures in the current transaction.</li>
</ul>
</li>
</ul>
<p>To reduce log space:</p>
<ul>
<li><code>flush()</code>
<ul>
<li>Explicitly flushes the redo log to disk.</li>
</ul>
</li>
<li><code>truncate()</code>
<ul>
<li>Applies the redo log to the external data segments and truncates the log.</li>
</ul>
</li>
</ul>
<p>Misc:</p>
<ul>
<li><code>query_options(region)</code>
<ul>
<li>Retrieves the options associated with a region of virtual address space.</li>
</ul>
</li>
<li><code>set_options(options)</code>
<ul>
<li>Sets the options associated with a region of virtual address space.</li>
</ul>
</li>
<li><code>create_log(options, len, mode)</code>
<ul>
<li>Creates a log segment with specified options, length, and mode.</li>
</ul>
</li>
</ul>
<h3 id="how-the-server-uses-the-primitives"><a class="markdownIt-Anchor" href="#how-the-server-uses-the-primitives"></a> How the Server Uses the Primitives</h3>
<p><img src="https://i.imgur.com/9YbgxG7.png" alt=""></p>
<ol>
<li><strong>Initialization</strong>: At the start of the code, the developer maps the address space of their process to external data segments and specifies the log segment for the code. This is done using the <code>initialize()</code>, <code>map()</code>, <code>unmap()</code>, and <code>create_log()</code> primitives.</li>
<li><strong>Begin transaction</strong>: When the developer wants to modify persistent data structures in their code, they begin a transaction using the <code>begin_transaction()</code> primitive. They can also specify a restore mode, which tells the system that the transaction will never abort and therefore no undo record needs to be created.</li>
<li><strong>Set range</strong>: Once the transaction has begun, the developer specifies the block of contiguous addresses that they plan to modify in this critical section using the <code>set_range()</code> primitive.</li>
<li><strong>Modify data structures</strong>: The developer can then modify in-memory versions of the persistent data structures using normal code.</li>
<li><strong>End transaction</strong>: When the developer is done with the changes, they call <code>end_transaction()</code> to commit the transaction. LRVM creates a redo log in memory of the changes that have been made to the persistent data structures.</li>
<li><strong>Flush and sync redo log</strong>: LRVM flushes the redo log to the log segment on the disk synchronously. However, the developer can specify a “no flush” mode in <code>end_transaction()</code> to allow the system to commit the transaction without blocking further execution.</li>
<li><strong>Abort transaction</strong>: If the transaction aborts, LRVM restores the original version of the portion of the virtual address space that was modified during the critical section by copying the undo record back into that space.</li>
</ol>
<h3 id="transaction-optimizations"><a class="markdownIt-Anchor" href="#transaction-optimizations"></a> Transaction Optimizations</h3>
<p>RVM has restricted transaction semantics, which means it doesn’t allow nested transactions and doesn’t require synchronous I/O for every commit. However, RVM provides opportunities for the developer to optimize the performance of the library for the chosen application.</p>
<ol>
<li>No-restore mode in the begin_transaction call. This mode tells RVN that the transaction starting is not going to abort, so there is no need to create an in-memory undo record. This reduces the amount of work that RVM has to do, and the overhead in performing a transaction is less.</li>
<li>No-flush mode in the end_transaction call. This mode tells RVM that there is no need to do a synchronous I/O at the commit point. The application developer takes a chance by using this mode because there is a <strong>window of vulnerability</strong> between end_transaction and the point at which the redo log has been forced to the disk. If there is a system cache within this time, the redo records that were written to in-memory may be lost.</li>
</ol>
<h3 id="implementation"><a class="markdownIt-Anchor" href="#implementation"></a> Implementation</h3>
<p><img src="https://i.imgur.com/F0Qr7yd.png" alt=""></p>
<p>RVM uses a logging strategy called <strong>no undo/redo value logging</strong>, which creates an undo record of the changes that are going to be made to virtual memory but is not a log that is persistent on the disk. The redo log consists of a transaction start and the changes that are made, but <strong>only new value records</strong> of committed transactions are written to the log. This is the reason for forward displacements because we know where to append to the log segment on the disk. Upon commit, the old value records in the virtual memory are replaced with the new value records, which is automatic. Only if you abort, you have to undo the changes. At that point, you have to force the redo log records to the log on the disk.</p>
<h3 id="crash-recovery"><a class="markdownIt-Anchor" href="#crash-recovery"></a> Crash Recovery</h3>
<p><img src="https://i.imgur.com/Ahooon9.png" alt=""></p>
<p>Crash recovery consists of RVM first reading the log from tail to head, then constructing an in-memory tree of the latest committed changes for each data segment encountered in the log. The trees are then traversed, applying modifications in them to the corresponding external data segment. Finally, the head and tail location information in the log status block is updated to reflect an empty log. The idempotency of recovery is achieved by delaying this step until all other recovery actions are complete.</p>
<h3 id="log-truncation"><a class="markdownIt-Anchor" href="#log-truncation"></a> Log Truncation</h3>
<p><img src="https://i.imgur.com/QJtTzvG.png" alt=""></p>
<p>Truncation is the process of reclaiming space allocated to log entries by applying the changes contained in them to the recoverable data segment. Periodic truncation is necessary because log space is finite, and is triggered whenever current log size exceeds a preset fraction of its total size.</p>
<p>Log truncation has proved to be the hardest part of RVM to implement correctly. To minimize implementation effort, we initially chose to <strong>reuse crash recovery code for truncation</strong>. In this approach, referred to as epoch truncation, the crash recovery procedure described above is applied to an initial part of the log while <strong>concurrent forward processing</strong> occurs in the rest of the log. The figure above depicts the layout of a log while an epoch truncation is in progress.</p>
<h2 id="l08b-riovista"><a class="markdownIt-Anchor" href="#l08b-riovista"></a> L08b: RioVista</h2>
<p>There are two orthogonal problems that lead to a system crash. One is <strong>power failure</strong>. The second is <strong>software failure</strong>.</p>
<p>So Rio Vista poses a very interesting rhetorical question. Suppose we postulate that the only source of system crash is software failure.</p>
<p>The authors propose a way to eliminate the heavyweight transaction properties of traditional persistent memory systems while improving performance by <strong>leveraging a battery-backed DRAM to create a persistent file cache</strong>.</p>
<h3 id="lrvm-revisited"><a class="markdownIt-Anchor" href="#lrvm-revisited"></a> LRVM Revisited</h3>
<p><img src="https://i.imgur.com/JHriocp.png" alt=""><br>
The upshot of LRVM implementation is there are <strong>three copies</strong> of the VM space done by LRVM to manage persistence for recoverable objects.</p>
<ol>
<li>The <strong>original data segment</strong>, which contains the persistent data that is brought into memory and modified during the transaction.</li>
<li>The <strong>in-memory undo record</strong>, which is created by LRVM when the application calls the <code>begin_transaction</code> primitive. This record contains the old contents of the portion of the memory that the transaction is going to modify.</li>
<li>The <strong>redo log record</strong>, which is written out to the disk at the end of the transaction and represents all the changes made to virtual memory within that critical section bound by a <code>begin_transaction</code> and end_transaction.</li>
</ol>
<h3 id="rio-file-cache"><a class="markdownIt-Anchor" href="#rio-file-cache"></a> Rio File Cache</h3>
<p><img src="https://i.imgur.com/YsZhTki.png" alt=""><br>
The Rio File Cache allows for file writes and normal program writes to memory-mapped files to become persistent by definition. This eliminates the need for synchronous writes to the disk and allows for arbitrary delay in writebacks.</p>
<h3 id="vista-rvm-on-top-of-rio"><a class="markdownIt-Anchor" href="#vista-rvm-on-top-of-rio"></a> Vista RVM on Top of Rio</h3>
<p><img src="https://i.imgur.com/BHJzAXL.png" alt=""><br>
Vista is an RVM library that has been implemented on top of the Rio file cache. The implementation of RVM using the Rio file cache is similar to LRVM, but it takes advantage of the fact that it is sitting on top of a Rio file cache.</p>
<p>When the data segment is mapped to the virtual memory, this portion of memory becomes persistent because it is contained in the file cache.</p>
<p>At the <code>begin_transaction</code> call, a before image is made of the portion of the virtual memory that we intend to modify during this transaction, which serves as the undo log. This undo log is backed up on the file cache and is therefore persistent.</p>
<p>During the execution of the transaction, normal program writes to the portion of the virtual memory where there are persistent data structures are reflected in the data segment, which is battery-backed.</p>
<p>At the <code>end_transaction</code> call, if the transaction is committed, no work needs to be done other than getting rid of the undo log because all the changes that the application developer intended to be committed to the data segment are already in there.</p>
<p>On the other hand, if the transaction aborts, the undo record that was created at the beginning of the transaction is used to copy the original image back into the portion of the virtual memory that was modified.</p>
<p>At the point of <code>end_transaction</code> for commit, all that needs to be done by Vista is to get rid of the undo log. There is <strong>no disk I/O involved</strong>, and there is <strong>no redo log</strong> because <strong>we are directly writing into the data segments</strong>.</p>
<h3 id="crash-recovery-2"><a class="markdownIt-Anchor" href="#crash-recovery-2"></a> Crash Recovery</h3>
<p>In the Vista implementation, the data segment is mapped to the virtual memory and is made persistent by definition, and an undo log is created at the begin_transaction call to serve as the undo record in case of transaction abort.</p>
<p><strong>At the end_transaction call, if it’s a commit, no work needs to be done except to get rid of the undo record,</strong> as all the changes to persistent data structures are already in the data segment.</p>
<p>If it aborts, the old image is restored back into the virtual memory, and the undo log is discarded. For crash recovery, the old image is recovered from the undo log, which survives crashes because it is in the Rio file cache.</p>
<p>Vista is simple compared to LRVM because there are <strong>no redo logs and no truncation code</strong>, and it performs significantly better than LRVM due to the absence of disk I/O.</p>
<h2 id="l08c-quicksilver"><a class="markdownIt-Anchor" href="#l08c-quicksilver"></a> L08c: Quicksilver</h2>
<ul>
<li>the structure of distributed systems today:</li>
</ul>
<p><img src="https://i.imgur.com/nJg7EiJ.png" alt=""></p>
<p>Modern distributed systems comprise <strong>user applications</strong> built on <strong>system services</strong> and a <strong>microkernel</strong>. System services handle components like file and web servers, while the microkernel manages processes and resources. This structure promotes extensibility and high performance in various operating system designs.</p>
<h3 id="quicksilver-system-architecture"><a class="markdownIt-Anchor" href="#quicksilver-system-architecture"></a> Quicksilver System Architecture</h3>
<p><img src="https://i.imgur.com/qKurR3L.png" alt=""><br>
Quicksilver aimed to introduce new services such as window managers and integrate communication into its design. It was the first OS to propose <strong>transactions for recovery management</strong>.</p>
<h3 id="ipc-fundamental-to-system-services"><a class="markdownIt-Anchor" href="#ipc-fundamental-to-system-services"></a> IPC Fundamental to System Services</h3>
<p><strong>Inter-process communication (IPC)</strong> is crucial to Quicksilver’s distributed system, with both synchronous and asynchronous client calls being supported. Quicksilver provides guarantees like <strong>no loss or duplication of requests</strong> and <strong>location transparency for client-server interactions</strong>.</p>
<p><img src="https://i.imgur.com/W9pipwG.png" alt=""></p>
<p>The kernel manages a data structure called a <strong>service queue</strong>, which is created by a server to handle client requests. When a client makes a request, the kernel informs the server via an <strong>upcall</strong>. The server executes the request, and the <strong>completion goes back into the service queue</strong>, signaling the <strong>kernel</strong> to provide a response to the client.</p>
<ul>
<li>At some point, the client needs to perform a <strong>wait</strong> operation on the service queue to indicate that it is ready to receive the response associated with its request. If the server has already processed the request and the response is available in the service queue, the kernel delivers the response to the client. If the response is not yet available, the client will wait until the response comes back.</li>
<li><strong>Multiple servers can wait on a service queue</strong>, which means any number of servers can <strong>offer</strong> their services for a particular service queue. The kernel can then choose a server based on their current workload when handling incoming requests.</li>
<li><strong>Client-server relationships are interchangeable.</strong> For example, a client may make a call to a file system server, which then acts as a client when making calls to a directory server or a data server. This flexibility allows for more complex interactions between system services.</li>
</ul>
<p>IPC <strong>guarantees no loss or duplication of requests</strong>, ensuring requests are completed <strong>exactly once</strong>. It also takes care of the <strong>reliability of data transfer</strong>, especially when clients and servers are on remote machines. Furthermore, the <strong>service queue data structure is globally unique</strong>, providing <strong>location transparency</strong> for client-server interactions, meaning clients don’t need to know where their requests are being serviced.</p>
<ul>
<li>IPC is the primary means of communication between clients and servers in Quicksilver. By integrating the <strong>recovery mechanism</strong> with IPC, the operating system ensures that every client-server interaction using IPC also includes <strong>transactional support</strong> for recovery.</li>
</ul>
<h3 id="bundling-distributed-ipc-and-x-actions"><a class="markdownIt-Anchor" href="#bundling-distributed-ipc-and-x-actions"></a> Bundling Distributed IPC and X Actions</h3>
<p><img src="https://i.imgur.com/mw32iRm.png" alt=""></p>
<ul>
<li>Quicksilver bundles IPC with recovery management using lightweight transactions, similar to LRVM.</li>
<li>IPC calls are tagged with transaction ID.</li>
<li>A shadow graph structure emerges from client-server interactions, showing the trail of these interactions.</li>
<li>The transaction tree has a root (owner) and participants.</li>
<li>Transaction managers on different nodes communicate with no extra overhead, as communication is piggybacked on regular IPC.</li>
<li>The transaction tree can span multiple nodes or sites.</li>
<li>Transactions are provided for recovery purposes, and the client-server relationship can traverse multiple nodes, requiring multi-site atomicity for recoverability.</li>
</ul>
<h3 id="transaction-management"><a class="markdownIt-Anchor" href="#transaction-management"></a> Transaction Management</h3>
<p><img src="https://i.imgur.com/Am8bHDT.png" alt=""></p>
<ul>
<li>Transaction managers maintain transaction trees for client-server interactions.</li>
<li>The owner of a transaction tree can delegate ownership to another node, which is useful when clients are fragile and may go away.</li>
<li>Quicksilver handles the heavy lifting of maintaining the transaction tree for recovery purposes.</li>
</ul>
<h3 id="distributed-transaction"><a class="markdownIt-Anchor" href="#distributed-transaction"></a> Distributed Transaction</h3>
<p><img src="https://i.imgur.com/ShYcte2.png" alt=""></p>
<ul>
<li>Transaction managers are responsible for all client-server interactions that touch a particular node.</li>
<li>The graph structure of the transaction tree helps reduce network communication.</li>
<li>Brittle nodes in the system, like client nodes, may designate the coordinator to a more robust node like a file server.</li>
<li>Transaction managers log periodically to persistent store, creating checkpoint records for recoverability reasons.</li>
<li>Distributed system failures can happen at any point, and transactions are not aborted at the first indication of failure, allowing error reporting to continue and partial failures to be cleaned up when the coordinator initiates termination.</li>
</ul>
<h3 id="commit-initiated-by-coordinator"><a class="markdownIt-Anchor" href="#commit-initiated-by-coordinator"></a> Commit Initiated by Coordinator</h3>
<p><img src="https://i.imgur.com/H7XKwFQ.png" alt=""></p>
<ul>
<li>The transaction tree gets into gear when the client-server relationship completes its action.</li>
<li>The coordinator initiates the termination of a transaction, which can be either commit or abort.</li>
<li>Different commit protocols can be chosen depending on the criticality of states and nature of the breadcrumbs left behind in different sites.</li>
<li>Examples: Persistent servers like file systems may need a two-phase commit protocol, while a window manager may only need a one-phase commit protocol.</li>
</ul>
<ol start="12">
<li>Upshot of Bundling IPC and Recovery</li>
</ol>
<p><img src="https://i.imgur.com/Em1uaQg.png" alt=""></p>
<ul>
<li>Bundling IPC and recovery management allows services to safely collect breadcrumbs left behind in all touched places.</li>
<li>No extra communication is needed for recovery management.</li>
<li>Quicksilver provides mechanisms; the policy is up to each service.</li>
<li>Overhead for recovery management in Quicksilver is similar to LRVM.</li>
</ul>
<h3 id="implementation-notes"><a class="markdownIt-Anchor" href="#implementation-notes"></a> Implementation Notes</h3>
<ul>
<li>Log maintenance is a key aspect of Quicksilver implementation.</li>
<li>Transaction managers write log records for recovering persistent state and periodically force in-memory log segments to storage for persistence.</li>
<li>Frequency of log force impacts performance and can also be initiated by applications.</li>
<li>Services need to carefully choose mechanisms based on their recovery requirements.</li>
</ul>
<h3 id="quicksilver-conclusion"><a class="markdownIt-Anchor" href="#quicksilver-conclusion"></a> Quicksilver Conclusion</h3>
<ul>
<li>Quicksilver demonstrates how enduring concepts, such as using transactions for state recovery, have stood the test of time.</li>
<li>Commercial operating systems focus on performance, often putting reliability in the back seat.</li>
<li>Storage class memories, with latency properties similar to DRAM and non-volatile nature, may lead to a resurgence of transactions in operating systems in the future.</li>
</ul>

</div>


  <div class="book-comments">
    




  </div>



<script src="/js/book-post.js"></script>


<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.js" integrity="sha384-97gW6UIJxnlKemYavrqDHSX3SiygeOwIZhwyOKRfSaf0JWKRVj9hLASHgFTzT+0O" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">
  
  <div class="divider"></div>
</div>

  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/js/book-toc.js"></script>

</div>

      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/js/book.js"></script>
